{"meta":{"title":"Jack's Blog","subtitle":"","description":"","author":"Gold_Jack","url":"https://gold-jack.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-09-28T09:27:47.000Z","updated":"2022-09-28T09:28:08.822Z","comments":false,"path":"tags/index.html","permalink":"https://gold-jack.github.io/tags/index.html","excerpt":"","text":""},{"title":"projects","date":"2022-09-28T13:25:09.000Z","updated":"2022-09-28T13:25:09.959Z","comments":true,"path":"projects/index.html","permalink":"https://gold-jack.github.io/projects/index.html","excerpt":"","text":""},{"title":"search","date":"2022-09-28T13:10:45.000Z","updated":"2022-09-28T13:11:09.599Z","comments":true,"path":"search/index.html","permalink":"https://gold-jack.github.io/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-28T09:26:31.000Z","updated":"2022-09-28T09:27:36.613Z","comments":false,"path":"categories/index.html","permalink":"https://gold-jack.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"AI作画","slug":"notes/AI作画","date":"2022-10-19T16:00:00.000Z","updated":"2022-10-20T14:02:38.827Z","comments":true,"path":"2022/10/20/notes/AI作画/","link":"","permalink":"https://gold-jack.github.io/2022/10/20/notes/AI%E4%BD%9C%E7%94%BB/","excerpt":"","text":"AI作画TODO、需求 用户登陆、交互界面（类似于stable-duffision-webui、DiffusionBee） 批量上传、下载图片 用户通过stable diffusion的txt2img和img2img生成自己想要的图片 用户指定关键词（class），上传20张左右reference-image，系统使用dreambooth训练（目前卡在deepspeed加速器下载），形成用户自己的textual-Inversion模型，可以在prompt中使用，得到特定的class图片（参考：https://www.bilibili.com/video/BV1TT411P7qq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ac1b24359a7d27b63248ae1c80f2ba6c） 改变prompt中的整体性关键词，系统通过自动调参，使图像产生明显趋向用户想法的变化。如：把”an oak tree on the fields in summer”中的summer换成winter，系统会自动把茂密的绿叶换成叶子掉光的树枝。（参考：https://www.bilibili.com/video/BV1b24y197H1/?spm_id_from=333.788&amp;vd_source=ac1b24359a7d27b63248ae1c80f2ba6c） 改变prompt中的局部性关键词，系统能使用某种方法（目前没有思路），系统重新生成图片的时间明显缩短。 多平台（web-&gt;安卓-&gt;IOS） 一些随记（不用看）AI作画是图象增加噪点的逆过程，细节缺乏的图片也可以认为是带噪点的图片，对缺乏的细节进行补充也是降噪的过程。这个部分其实这些模型都可以通过添加关键字然后基于init_image进行降噪，我们主要要做的事是：1. 让模型专注于这个精化需求的过程，提高从底图到增加细节的新图的速度 2. 设计出一个比较好的交互逻辑，提高精化需求的效率 带星号的是可能找到模型结构（开源）的 *stable diffusion &amp; *disco diffusion有webui，也有命令行，但没找到开源的代码（指模型的神经网络结构），目前确定的是，可以调整输入、输出图片的各项参数，采样步数，来取得不同的结果。 https://github.com/alembics/disco-diffusionhttps://github.com/CompVis/stable-diffusion *GANArt生成肖像画，用StyleGAN2 ADA进行训练（不知道这个算不算是开源模型了） github：https://github.com/DeewakarChakraborty/GANArt-Using-AI-to-create-Portraits 在GANArt-TransferLearning.ipynb中貌似找到了网络结构的输出 GANscapes使用GAN生成印象画作，粗读了代码，没有找到具体的网络结构，但是可调参数比diffusion多。github的issue里有人表示，colab挂了，可能要在本地跑。 github：https://github.com/robgon-art/GANscapes 文章：GANscapes: Using AI to Create New Impressionist Paintings *Style-transfer-AI-painting风格迁移的模型——AI绘画大师 github:https://github.com/stonehard0208/Style-transfer-AI-painting 主要参考文献：https://arxiv.org/abs/1508.06576（有代码，还没下载下来看） Disco Diffusion官网：https://github.com/alembics/disco-diffusion colab： Hugging face模型下载网站：https://huggingface.co/models Stable Diffusion官网：https://github.com/CompVis/stable-diffusion 部署（windows） *运行conda命令时，请关闭代理，运行pip时，可以开启代理加速 12conda env create -f environment.yamlconda activate ldm 12# 必要依赖包pip install einops==0.3.0 torch-fidelity==0.3.0 transformers==4.19.2 torchmetrics==0.6.0 kornia==0.6 opencv-python-headless imgaug==0.2.6 12345pip install albumentations==0.4.3 diffusers opencv-python==4.1.2.30 pudb==2019.2 invisible-watermark imageio==2.9.0 imageio-ffmpeg==0.4.2 pytorch-lightning==1.4.2 omegaconf==2.1.1 test-tube&gt;=0.7.5 streamlit&gt;=0.73.1 pip install -e git+https://github.com/CompVis/taming-transformers.git@master#egg=taming-transformers pip install -e git+https://github.com/openai/CLIP.git@main#egg=clip pip install -e . 如果上述过程中有报错，可以忽略。numpy包如果版本不对，可以删除后指定版本重新安装，即可避免报错。 *如果需要更新torch环境，可以运行以下代码 123conda install pytorch torchvision -c pytorchpip install transformers==4.19.2 diffusers invisible-watermarkpip install -e . numpy版本问题 12pip uninstall numpy # 可多次运行，一定要保证numpy的各个版本被全部卸载干净pip install numpy==1.23 运行官方运行模板 1python scripts/txt2img.py --prompt &quot;a photograph of an astronaut riding a horse&quot; --plms 常用参数 123456--prompt # 图片的描述--W, --H # 图片的宽高，默认512*512，3080 10G只能一次训练一张。512*256可以一次训练6张--n_samples # 一次的样本数，默认为2--plms # plms采样方法--ddim_steps # ddim采样步数，默认50，采用ddim采样--n_iter # 最后生成的图片数量 其他的参数及详情，见scripts\\txt2img.py 生成涂鸦风的公主肖像 plms sampling 1python .\\scripts\\txt2img.py --prompt &quot;an graffiti of a portrait of princess&quot; --plms --n_samples 1 --n_iter 10 --outdir .\\outputs\\oil-painting --W 512 --H 512 ddim sampling 1python .\\scripts\\txt2img.py --prompt &quot;an graffiti of a portrait of princess&quot; --ddim_eta 0.0 --ddim_steps 100 --n_samples 1 --n_iter 10 --outdir .\\outputs\\oil-painting --W 512 --H 512 Dreambooth根据训练图，训练自己的模型 教程中要求3090 24G算力，本机不够：https://github.com/gammagec/Dreambooth-SD-optimized deepspeed优化显存至8GB：https://github.com/ShivamShrirao/diffusers/tree/main/examples/dreambooth 模型训练1python .\\main.py --base .\\configs\\stable-diffusion\\v1 -finetune_unfrozen.yaml -t --actual_resume .\\models\\ldm\\stable-diffusion-v1\\sd-v1-4-full-ema.ckpt -n train-starcraft1 --gpus &quot;0,&quot; --data_root .\\samples\\starcraft1-ref\\ --reg_data_root .\\samples\\starcraft1-train\\ --class_word starcraft1 使用dreambooth加速 首先下载diffusers 1pip install diffusers 加速器配置 1accelerate config 可以使用deepspeed减少显存*（出错） 1pip install deepspeed 使用加速器训练 1234567891011121314151617accelerate launch train_dreambooth.py \\ --pretrained_model_name_or_path=sd-v1-4-full-ema.ckpt \\ --instance_data_dir=samples/starcraft1-train \\ --class_data_dir=samples/starcraft1-ref \\ --output_dir=outputs \\ --with_prior_preservation --prior_loss_weight=1.0 \\ --instance_prompt=&quot;a photo of starcraft1&quot; \\ --class_prompt=&quot;starcraft1&quot; \\ --resolution=512 \\ --train_batch_size=1 \\ --gradient_accumulation_steps=1 --gradient_checkpointing \\ --learning_rate=5e-6 \\ --lr_scheduler=&quot;constant&quot; \\ --lr_warmup_steps=0 \\ --num_class_images=200 \\ --max_train_steps=800 \\ --mixed_precision=fp16 1accelerate launch train_dreambooth.py --pretrained_model_name_or_path=sd-v1-4-full-ema.ckpt --instance_data_dir=samples/starcraft1-train --class_data_dir=samples/starcraft1-ref --output_dir=outputs --with_prior_preservation --prior_loss_weight=1.0 --instance_prompt=&quot;a photo of starcraft1&quot; --class_prompt=&quot;starcraft1&quot; --resolution=512 --train_batch_size=1 --gradient_accumulation_steps=1 --gradient_checkpointing --learning_rate=5e-6 --lr_scheduler=&quot;constant&quot; --lr_warmup_steps=0 --num_class_images=200 --max_train_steps=800 --mixed_precision=fp16","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"ai_painting","slug":"ai-painting","permalink":"https://gold-jack.github.io/tags/ai-painting/"},{"name":"diffusion model","slug":"diffusion-model","permalink":"https://gold-jack.github.io/tags/diffusion-model/"},{"name":"textual inversion","slug":"textual-inversion","permalink":"https://gold-jack.github.io/tags/textual-inversion/"}]},{"title":"《买卖股票》(DP)","slug":"leetcode/《买卖股票》(DP)","date":"2022-10-14T16:00:00.000Z","updated":"2022-10-15T05:31:26.762Z","comments":true,"path":"2022/10/15/leetcode/《买卖股票》(DP)/","link":"","permalink":"https://gold-jack.github.io/2022/10/15/leetcode/%E3%80%8A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E3%80%8B(DP)/","excerpt":"","text":"121. 买卖股票的最佳时机难度简单2615收藏分享切换为英文接收动态反馈 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 Java1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; int n = prices.length; int[] profits = new int[n]; profits[0] = 0; int preMin = prices[0]; for (int i = 1; i &lt; n; i++) &#123; profits[i] = Math.max(Math.max(prices[i] - preMin, profits[i - 1]), 0); if (prices[i] &lt; preMin) preMin = prices[i]; &#125; return profits[n - 1]; &#125;&#125; 122. 买卖股票的最佳时机 II难度中等1857收藏分享切换为英文接收动态反馈 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 Java123456789class Solution &#123; public int maxProfit(int[] prices) &#123; int res = 0; for (int i = 1; i &lt; prices.length; i++) &#123; res += Math.max(prices[i] - prices[i - 1], 0); &#125; return res; &#125;&#125; 123. 买卖股票的最佳时机 III难度困难1248收藏分享切换为英文接收动态反馈 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 12345输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 123输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 12输入：prices = [1]输出：0 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 Java看答案的123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int n = prices.length; int[][] dp = new int[n][4]; dp[0][0] = dp[0][2] = -prices[0]; dp[0][1] = dp[0][3] = 0; for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = Math.max(dp[i - 1][0], -prices[i - 1]); dp[i][1] = Math.max(dp[i - 1][1], dp[i][0] + prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i][1] - prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i][2] + prices[i]); &#125; return dp[n - 1][3]; &#125;&#125; 官方解法1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; int n = prices.length; int buy1 = -prices[0], sell1 = 0; int buy2 = -prices[0], sell2 = 0; for (int i = 1; i &lt; n; ++i) &#123; buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]); &#125; return sell2; &#125;&#125; 188. 买卖股票的最佳时机 IV难度困难823收藏分享切换为英文接收动态反馈 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 123输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 1234输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 0 &lt;= k &lt;= 100 0 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 Java12345678910111213141516171819class Solution &#123; public int maxProfit(int k, int[] prices) &#123; int[] buy = new int[k]; // buy1, buy2, ..., buyk int[] sell = new int[k + 1]; // sell1, sell2, ..., sellk int n = prices.length; for (int i = 0; i &lt; k; i++) &#123; buy[i] = -prices[0]; sell[i] = 0; &#125; sell[k] = 0; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; buy[j] = Math.max(buy[j], sell[j == 0 ? k : j - 1] - prices[i]); sell[j] = Math.max(sell[j], buy[j] + prices[i]); &#125; &#125; return sell[k - 1]; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://gold-jack.github.io/tags/dp/"}]},{"title":"《打家劫舍》(DP)","slug":"leetcode/《打家劫舍》(DP)","date":"2022-10-14T16:00:00.000Z","updated":"2022-10-15T05:31:37.544Z","comments":true,"path":"2022/10/15/leetcode/《打家劫舍》(DP)/","link":"","permalink":"https://gold-jack.github.io/2022/10/15/leetcode/%E3%80%8A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E3%80%8B(DP)/","excerpt":"","text":"198. 打家劫舍难度中等2318收藏分享切换为英文接收动态反馈 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 Java123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; else if (nums.length == 2) return Math.max(nums[0], nums[1]); int n = nums.length; int[] money = new int[n]; money[0] = nums[0]; money[1] = nums[1]; money[2] = nums[0] + nums[2]; for (int i = 3; i &lt; n; i++) &#123; money[i] = Math.max(money[i - 2], money[i - 3]) + nums[i]; &#125; return Math.max(money[n - 1], money[n - 2]); &#125;&#125; 213. 打家劫舍 II难度中等1175收藏分享切换为英文接收动态反馈 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 1234输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 12输入：nums = [1,2,3]输出：3 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 Java12345678910111213141516171819202122232425class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; else if (nums.length == 2) return Math.max(nums[0], nums[1]); else if (nums.length == 3) return Math.max(Math.max(nums[0], nums[1]), nums[2]); int n = nums.length; int[] money_1 = new int[n]; int[] money_2 = new int[n + 1]; money_1[0] = nums[0]; money_1[1] = nums[1]; money_1[2] = nums[0] + nums[2]; money_2[1] = nums[1]; money_2[2] = nums[2]; money_2[3] = nums[1] + nums[3]; for (int i = 3; i &lt; n; i++) &#123; if (i != n - 1) &#123; money_1[i] = Math.max(money_1[i - 2], money_1[i - 3]) + nums[i]; money_2[i + 1] = Math.max(money_2[i - 1], money_2[i - 2]) + nums[i + 1]; &#125; else &#123; money_1[i] = Math.max(money_1[i - 1], money_1[i - 2]); &#125; &#125; return Math.max(Math.max(money_1[n - 1], money_1[n - 2]), Math.max(money_2[n - 1], money_2[n - 2])); &#125;&#125; 740. 删除并获得点数难度中等684收藏分享切换为英文接收动态反馈 给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 12345输入：nums = [3,4,2]输出：6解释：删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2： 123456输入：nums = [2,2,3,3,3,4]输出：9解释：删除 3 获得 3 个点数，接着要删除两个 2 和 4 。之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。总共获得 9 个点数。 提示： 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 104 Java1234567891011121314151617181920212223class Solution &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public int deleteAndEarn(int[] nums) &#123; int max = -99999; for (Integer i : nums) &#123; max = Math.max(max, i); map.put(i, map.getOrDefault(i, 0) + 1); &#125; int n = max + 1; int[] a = new int[n]; int[] dp = new int[n]; for (int i = 0; i &lt; n; i++) &#123; a[i] = map.getOrDefault(i, 0) * i; if (i == 0 || i == 1) dp[i] = a[i]; else if (i == 2) dp[i] = dp[i - 2] + a[i]; else dp[i] = Math.max(dp[i - 2], dp[i - 3]) + a[i]; &#125; return Math.max(dp[n - 1], dp[n - 2]); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://gold-jack.github.io/tags/dp/"}]},{"title":"62.不同路径 63.不同路径Ⅱ","slug":"leetcode/62.不同路径-63.不同路径Ⅱ","date":"2022-10-09T16:00:00.000Z","updated":"2022-10-10T12:16:56.935Z","comments":true,"path":"2022/10/10/leetcode/62.不同路径-63.不同路径Ⅱ/","link":"","permalink":"https://gold-jack.github.io/2022/10/10/leetcode/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/","excerpt":"","text":"62. 不同路径难度中等1574收藏分享切换为英文接收动态反馈 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 Java12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] paths = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 || j == 0) &#123; paths[i][j] = 1; &#125; else &#123; paths[i][j] = paths[i - 1][j] + paths[i][j - 1]; &#125; &#125; &#125; return paths[m - 1][n - 1]; &#125;&#125; 63. 不同路径 II难度中等890收藏分享切换为英文接收动态反馈 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 Java123456789101112131415161718192021222324class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int[][] paths = new int[obstacleGrid.length + 1][obstacleGrid[0].length + 1]; for (int i = 0; i &lt; paths.length; i++) &#123; paths[i][0] = 0; &#125; Arrays.fill(paths[0], 0); for (int i = 1; i &lt; paths.length; i++) &#123; for (int j = 1; j &lt; paths[0].length; j++) &#123; if (obstacleGrid[i - 1][j - 1] == 1) &#123; paths[i][j] = 0; continue; &#125; if (i == 1 &amp;&amp; j == 1) &#123; paths[i][j] = 1; continue; &#125; paths[i][j] = paths[i - 1][j] + paths[i][j - 1]; &#125; &#125; return paths[paths.length - 1][paths[0].length - 1]; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"graph","slug":"graph","permalink":"https://gold-jack.github.io/tags/graph/"},{"name":"dp","slug":"dp","permalink":"https://gold-jack.github.io/tags/dp/"}]},{"title":"515.在每个树行中找最大值","slug":"leetcode/515.在每个树行中找最大值","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-09T03:50:40.651Z","comments":true,"path":"2022/10/09/leetcode/515.在每个树行中找最大值/","link":"","permalink":"https://gold-jack.github.io/2022/10/09/leetcode/515.%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"515. 在每个树行中找最大值难度中等278收藏分享切换为英文接收动态反馈 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例1： 12输入: root = [1,3,2,5,3,null,9]输出: [1,3,9] 示例2： 12输入: root = [1,2,3]输出: [1,3] 提示： 二叉树的节点个数的范围是 [0,104] -231 &lt;= Node.val &lt;= 231 - 1 Java123456789101112131415161718class Solution &#123; // key: depth, value: max HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; largestValues(TreeNode root) &#123; traverse(root, 0); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(map.values()); return res; &#125; void traverse(TreeNode node, int depth) &#123; if (node == null) return; if (node.val &gt;= map.getOrDefault(depth, Integer.MIN_VALUE)) map.put(depth, node.val); traverse(node.left, depth + 1); traverse(node.right, depth + 1); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"129.求根节点到叶节点数字之和","slug":"leetcode/129.求根节点到叶节点数字之和","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T09:34:59.348Z","comments":true,"path":"2022/10/08/leetcode/129.求根节点到叶节点数字之和/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/","excerpt":"","text":"129.求根节点到叶节点数字之和题目描述129. 求根节点到叶节点数字之和难度中等585收藏分享切换为英文接收动态反馈 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。 叶节点 是指没有子节点的节点。 示例 1： 123456输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 1-&gt;2 代表数字 12从根到叶子节点路径 1-&gt;3 代表数字 13因此，数字总和 = 12 + 13 = 25 示例 2： 1234567输入：root = [4,9,0,5,1]输出：1026解释：从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491从根到叶子节点路径 4-&gt;0 代表数字 40因此，数字总和 = 495 + 491 + 40 = 1026 提示： 树中节点的数目在范围 [1, 1000] 内 0 &lt;= Node.val &lt;= 9 树的深度不超过 10 Java我的解法1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res = 0; public int sumNumbers(TreeNode root) &#123; getSum(root, 0); return res; &#125; void getSum(TreeNode node, int num) &#123; if (node == null) return; num = num * 10 + node.val; if (node.left == null &amp;&amp; node.right == null) &#123; res += num; return; &#125; getSum(node.left, num); getSum(node.right, num); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"199.二叉树的右视图 513.找树左下角的值","slug":"leetcode/199.二叉树的右视图","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T10:00:12.679Z","comments":true,"path":"2022/10/08/leetcode/199.二叉树的右视图/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","excerpt":"","text":"199.二叉树的右视图题目描述199. 二叉树的右视图难度中等765收藏分享切换为英文接收动态反馈 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 12输入: [1,2,3,null,5,null,4]输出: [1,3,4] 示例 2: 12输入: [1,null,3]输出: [1,3] 示例 3: 12输入: []输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 &lt;= Node.val &lt;= 100 Java12345678910111213141516class Solution &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; getRightest(root, 0); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(map.values()); return res; &#125; void getRightest(TreeNode node, int depth) &#123; if (node == null) return; map.put(depth, node.val); getRightest(node.left, depth + 1); getRightest(node.right, depth + 1); &#125;&#125; 513.找树左下角的值题目描述513. 找树左下角的值难度中等391收藏分享切换为英文接收动态反馈 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 12输入: root = [2,1,3]输出: 1 示例 2: 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 Java12345678910111213141516171819202122232425class Solution &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int maxDepth = -1; public int findBottomLeftValue(TreeNode root) &#123; traverse(root, 0); // 通过depth最大值找最底的元素 return map.get(maxDepth); &#125; // 后续遍历找最左 void traverse(TreeNode node, int depth) &#123; if (node == null) return; traverse(node.left, depth + 1); traverse(node.right, depth + 1); if (map.get(depth) != null) return; map.put(depth, node.val); if (depth &gt; maxDepth) &#123; maxDepth = depth; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://gold-jack.github.io/tags/dfs/"},{"name":"re","slug":"re","permalink":"https://gold-jack.github.io/tags/re/"}]},{"title":"112.路径总和 113.路径总和Ⅱ 437.路径总和Ⅲ","slug":"leetcode/112.路径总和-113.路径总和Ⅱ-437.路径总和Ⅲ","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T11:15:27.869Z","comments":true,"path":"2022/10/08/leetcode/112.路径总和-113.路径总和Ⅱ-437.路径总和Ⅲ/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1-437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A2/","excerpt":"","text":"112. 路径总和难度简单1012收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Java1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; return judge(root, 0, targetSum); &#125; boolean judge(TreeNode node, int sum, int targetSum) &#123; if ( node == null ) return false; // 如果是叶子节点的话 sum += node.val; if ( node.left == null &amp;&amp; node.right == null) &#123; return sum == targetSum; &#125; return judge(node.left, sum, targetSum) || judge(node.right, sum, targetSum); &#125;&#125; 113. 路径总和 II难度中等851收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 12输入：root = [1,2,3], targetSum = 5输出：[] 示例 3： 12输入：root = [1,2], targetSum = 0输出：[] 提示： 树中节点总数在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Java12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; dfs(root, 0, targetSum); return res; &#125; void dfs(TreeNode node, int sum, int targetSum) &#123; if (node == null) return; sum += node.val; path.add(node); // 如果node是子节点的话 if (node.left == null &amp;&amp; node.right == null) &#123; if (sum == targetSum) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (TreeNode tn : path) list.add(tn.val); res.add(list); &#125; path.remove(node); return; &#125; dfs(node.left, sum, targetSum); dfs(node.right, sum, targetSum); path.remove(node); &#125;&#125; 437. 路径总和 III难度中等1473收藏分享切换为英文接收动态反馈 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 示例 1： 123输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。 示例 2： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：3 提示: 二叉树的节点个数的范围是 [0,1000] -109 &lt;= Node.val &lt;= 109 -1000 &lt;= targetSum &lt;= 1000 通过次数196,522 提交次数370,042 Java前缀和解法时间复杂度O(n) 123456789101112131415161718192021222324252627282930313233343536373839static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125; &#125; int res = 0; // key是前缀和，value是出现key前缀和的次数 HashMap&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); public int pathSum(TreeNode root, int targetSum) &#123; map.put(0L, 1); getPrefixCount(root, targetSum, 0L); return res; &#125; /** * 前缀和：从root到node（不包括node）的所有节点的val之和 */ void getPrefixCount(TreeNode node, int targetSum, long currSum) &#123; if (node == null) return; currSum += node.val; res += map.getOrDefault(currSum - targetSum, 0); map.put(currSum, map.getOrDefault(currSum, 0) + 1); getPrefixCount(node.left, targetSum, currSum); getPrefixCount(node.right, targetSum, currSum); map.put(currSum, map.get(currSum) - 1); &#125; 暴力解法（超时）时间复杂度O(n^2) 1234567891011121314151617int res = 0; List&lt;TreeNode&gt; path = new ArrayList&lt;&gt;(); public int pathSum(TreeNode root, int targetSum) &#123; traverse(root, targetSum); return res; &#125; void traverse(TreeNode node, int targetSum) &#123; if (node == null) return; if (node.left != null) traverse(node.left, targetSum); dfs(node, 0, targetSum); path.clear(); if (node.right != null) traverse(node.right, targetSum); &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://gold-jack.github.io/tags/dfs/"},{"name":"prefix_sum","slug":"prefix-sum","permalink":"https://gold-jack.github.io/tags/prefix-sum/"}]},{"title":"114.二叉树展开为链表","slug":"leetcode/114.二叉树展开为链表","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T09:36:53.667Z","comments":true,"path":"2022/10/08/leetcode/114.二叉树展开为链表/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","excerpt":"","text":"114.二叉树展开为链表题目描述114. 二叉树展开为链表难度中等1316收藏分享切换为英文接收动态反馈 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 12输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [0]输出：[0] 提示： 树中结点数在范围 [0, 2000] 内 -100 &lt;= Node.val &lt;= 100 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？ Java我的解法123456789101112131415161718class Solution &#123; ArrayList&lt;TreeNode&gt; pre = new ArrayList&lt;&gt;(); public void flatten(TreeNode root) &#123; preTraverse(root); for (int i = 0; i &lt; pre.size() - 1; i++) &#123; pre.get(i).left = null; pre.get(i).right = pre.get(i + 1); &#125; &#125; void preTraverse(TreeNode node) &#123; if (node == null) return; pre.add(node); preTraverse(node.left); preTraverse(node.right); &#125;&#125; 评论区解法（更精妙）123456789101112class Solution &#123; TreeNode last = null; public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = last; root.left = null; last = root; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"200.岛屿数量 463.岛屿的周长 695.岛屿的最大面积 1254.统计封闭岛屿的数目","slug":"leetcode/200.岛屿数量 463.岛屿的周长 695.岛屿的最大面积 1254.统计封闭岛屿的数目","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T11:12:07.204Z","comments":true,"path":"2022/10/08/leetcode/200.岛屿数量 463.岛屿的周长 695.岛屿的最大面积 1254.统计封闭岛屿的数目/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%20463.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF%20695.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%201254.%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"200. 岛屿数量难度中等1926收藏分享切换为英文接收动态反馈 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 示例 2： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39; Java递归 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; class Loc &#123; int x; int y; public Loc(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125; public int numIslands(char[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] vis = new int[m][n]; int islandCnt = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ( grid[i][j] == &#x27;0&#x27; || vis[i][j] == 1) continue; infect(grid, vis, i, j); islandCnt++; &#125; &#125; return islandCnt; &#125; private void infect(char[][] grid, int[][] vis, int x, int y) &#123; if ( x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] == &#x27;0&#x27; || vis[x][y] == 1) return; vis[x][y] = 1; infect(grid, vis, x - 1, y); infect(grid, vis, x + 1, y); infect(grid, vis, x, y - 1); infect(grid, vis, x, y + 1); &#125;&#125; 非递归（超时）123456789101112131415161718192021DFS函数部分，其余部分与递归一致// deprecated 非递归超时 private void checkIsland(char[][] grid, int[][] vis, int x, int y, int m, int n) &#123; Queue&lt;Loc&gt; queue = new LinkedList&lt;&gt;(); queue.add(new Loc(x, y)); while( !queue.isEmpty() ) &#123; Loc p = queue.peek(); queue.remove(p); int px = p.x; int py = p.y; vis[px][py] = 1; // check left if ( py - 1 &gt;= 0 &amp;&amp; grid[px][py - 1] == &#x27;1&#x27; &amp;&amp; vis[px][py - 1] == 0) queue.add(new Loc(px, py - 1)); // check up if ( px - 1 &gt;= 0 &amp;&amp; grid[px - 1][py] == &#x27;1&#x27; &amp;&amp; vis[px - 1][py] == 0 ) queue.add(new Loc(px - 1, py)); // check right if ( py + 1 &lt; n &amp;&amp; grid[px][py + 1] == &#x27;1&#x27; &amp;&amp; vis[px][py + 1] == 0) queue.add(new Loc(px, py + 1)); // check down if ( px + 1 &lt; m &amp;&amp; grid[px + 1][py] == &#x27;1&#x27; &amp;&amp; vis[px + 1][py] == 0) queue.add(new Loc(px + 1, py)); &#125; &#125; 463. 岛屿的周长难度简单601收藏分享切换为英文接收动态反馈 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。 网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 1： 123输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边 示例 2： 12输入：grid = [[1]]输出：4 示例 3： 12输入：grid = [[1,0]]输出：4 提示： row == grid.length col == grid[i].length 1 &lt;= row, col &lt;= 100 grid[i][j] 为 0 或 1 Java1234567891011121314151617181920212223242526272829303132class Solution &#123; int total_len = 0; public int islandPerimeter(int[][] grid) &#123; boolean isDone = false; for (int i = 0; i &lt; grid.length; i++) &#123; for ( int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !isDone) &#123; count(grid, i, j); isDone = true; &#125; &#125; &#125; return total_len; &#125; private void count(int[][] grid, int x, int y) &#123; if (x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] != 1) return; grid[x][y]++; if ( x - 1 &lt; 0 || grid[x - 1][y] == 0) total_len++; if ( x + 1 &gt;= grid.length || grid[x + 1][y] == 0) total_len++; if ( y - 1 &lt; 0 || grid[x][y - 1] == 0) total_len++; if ( y + 1 &gt;= grid[0].length || grid[x][y + 1] == 0) total_len++; count(grid, x - 1, y); count(grid, x + 1, y); count(grid, x, y - 1); count(grid, x, y + 1); &#125;&#125; 695. 岛屿的最大面积难度中等858收藏分享切换为英文接收动态反馈 给你一个大小为 m x n 的二进制矩阵 grid 。 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 岛屿的面积是岛上值为 1 的单元格的数目。 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。 示例 1： 123输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]输出：6解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。 示例 2： 12输入：grid = [[0,0,0,0,0,0,0,0]]输出：0 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 50 grid[i][j] 为 0 或 1 Java 1234567891011121314151617181920212223242526272829class Solution &#123; int max_area = 0; int curArea = 0; public int maxAreaOfIsland(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; i++) &#123; for ( int j = 0; j &lt; grid[0].length; j++) &#123; if ( grid[i][j] == 1) &#123; curArea = 0; countArea(grid, i, j); if ( curArea &gt; max_area ) max_area = curArea; &#125; &#125; &#125; return max_area; &#125; private void countArea(int[][] grid, int x, int y) &#123; if ( x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] != 1) return; grid[x][y]++; curArea++; countArea(grid, x + 1, y); countArea(grid, x - 1, y); countArea(grid, x, y + 1); countArea(grid, x, y - 1); &#125;&#125; 1254. 统计封闭岛屿的数目难度中等164收藏分享切换为英文接收动态反馈 二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。 请返回 封闭岛屿 的数目。 示例 1： 1234输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]输出：2解释：灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。 示例 2： 12输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]输出：1 示例 3： 12345678输入：grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]]输出：2 提示： 1 &lt;= grid.length, grid[0].length &lt;= 100 0 &lt;= grid[i][j] &lt;=1 Java 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; int cnt = 0; public int closedIsland(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == 0 &amp;&amp; checkSurroundings(grid, i, j)) &#123; cnt++; &#125; &#125; &#125; return cnt; &#125; boolean checkSurroundings(int[][] grid, int x, int y) &#123; boolean flag = true; if (grid[x][y] == 0) grid[x][y]--; else return true; if (x - 1 &lt; 0 || x + 1 &gt;= grid.length || y - 1 &lt; 0 || y + 1 &gt;= grid[0].length) &#123; flag = false; &#125; // !!注意，如果这里将&amp;换成&amp;&amp;，且前面的flag是false，则后面的语句不会执行 if (x - 1 &gt;= 0) flag = flag &amp; checkSurroundings(grid, x - 1, y); if (x + 1 &lt; grid.length) flag = flag &amp; checkSurroundings(grid, x + 1, y); if (y - 1 &gt;= 0) flag = flag &amp; checkSurroundings(grid, x, y - 1); if (y + 1 &lt; grid[0].length) flag = flag &amp; checkSurroundings(grid, x, y + 1); return flag; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"dfs","slug":"dfs","permalink":"https://gold-jack.github.io/tags/dfs/"},{"name":"graph","slug":"graph","permalink":"https://gold-jack.github.io/tags/graph/"}]},{"title":"257.二叉树的所有路径","slug":"leetcode/257.二叉树的所有路径","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T09:46:45.304Z","comments":true,"path":"2022/10/08/leetcode/257.二叉树的所有路径/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","excerpt":"","text":"257.二叉树的所有路径题目描述257. 二叉树的所有路径难度简单824收藏分享切换为英文接收动态反馈 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 12输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 12输入：root = [1]输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 Java123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;String&gt; routes = new ArrayList&lt;&gt;(); String NEXT = &quot;-&gt;&quot;; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; if (root == null) return routes; traverse(root, &quot;&quot;); return routes; &#125; void traverse(TreeNode node, String path) &#123; if (node == null) return; if (path.isEmpty()) &#123; path = String.valueOf(node.val); &#125; else &#123; path += NEXT + String.valueOf(node.val); &#125; // 如果是叶节点 if (node.left == null &amp;&amp; node.right == null) &#123; routes.add(path); return; &#125; traverse(node.left, path); traverse(node.right, path); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"547.省份数量","slug":"leetcode/547.省份数量","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T10:17:29.655Z","comments":true,"path":"2022/10/08/leetcode/547.省份数量/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/","excerpt":"","text":"547.省份数量题目描述547. 省份数量难度中等879收藏分享切换为英文接收动态反馈 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： 12输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]输出：2 示例 2： 12输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]输出：3 提示： 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] Java12345678910111213141516171819202122232425262728293031class Solution &#123; int cnt = 0; public int findCircleNum(int[][] isConnected) &#123; int N = isConnected.length; int[] vis = new int[N]; for (int i = 0; i &lt; N; i++) &#123; for (int j = i + 1; j &lt; N; j++) &#123; if (isConnected[i][j] == 1 &amp;&amp; vis[i] != 1) &#123; cnt++; countProvince(isConnected, vis, N, i); &#125; &#125; &#125; for (int i = 0; i &lt; N; i++) if (vis[i] == 0) cnt++; return cnt; &#125; void countProvince(int[][] isConnected, int[] vis, int N, int curr) &#123; if (vis[curr] == 1) return; vis[curr] = 1; for (int i = 0; i &lt; N; i++) &#123; if (curr != i &amp;&amp; isConnected[curr][i] == 1) &#123; countProvince(isConnected, vis, N, i); &#125; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"dfs","slug":"dfs","permalink":"https://gold-jack.github.io/tags/dfs/"},{"name":"graph","slug":"graph","permalink":"https://gold-jack.github.io/tags/graph/"}]},{"title":"870.优势洗牌 - 每日一题","slug":"leetcode/870.优势洗牌---每日一题","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T09:31:42.590Z","comments":true,"path":"2022/10/08/leetcode/870.优势洗牌---每日一题/","link":"","permalink":"https://gold-jack.github.io/2022/10/08/leetcode/870.%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C---%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"870.优势洗牌 - 每日一题题目描述870. 优势洗牌难度中等296收藏分享切换为英文接收动态反馈 给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。 返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。 示例 1： 12输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]输出：[2,11,7,15] 示例 2： 12输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]输出：[24,32,8,12] 提示： 1 &lt;= nums1.length &lt;= 105 nums2.length == nums1.length 0 &lt;= nums1[i], nums2[i] &lt;= 109 Java答案解法时间复杂度O(nlogn) 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] advantageCount(int[] nums1, int[] nums2) &#123; int n = nums1.length; Integer[] idx_1 = new Integer[n]; Integer[] idx_2 = new Integer[n]; for (int i = 0; i &lt; n; i++) &#123; idx_1[i] = i; idx_2[i] = i; &#125; Arrays.sort(idx_1, Comparator.comparingInt(i -&gt; nums1[i])); Arrays.sort(idx_2, Comparator.comparingInt(i -&gt; nums2[i])); int[] res = new int[n]; int left = 0, right = n - 1; for (int i = 0; i &lt; n; i++) &#123; if (nums1[idx_1[i]] &gt; nums2[idx_2[left]]) &#123; res[idx_2[left]] = nums1[idx_1[i]]; left++; &#125; else &#123; res[idx_2[right]] = nums1[idx_1[i]]; right--; &#125; &#125; return res; &#125;&#125; 我的解法（超时）时间复杂度O(n^2) 最后差两个用例，66&#x2F;67没过 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[] advantageCount(int[] nums1, int[] nums2) &#123; int[] res = new int[nums2.length]; int[] vis = new int[nums1.length]; for (int i = 0; i &lt; nums2.length; i++) &#123; int min_diff_idx = -1; int min_diff = Integer.MAX_VALUE; int min_idx = 0; int min = Integer.MAX_VALUE; for (int j = 0; j &lt; nums1.length; j++) &#123; if (vis[j] != 1) &#123; if (nums1[j] - nums2[i] &gt; 0 &amp;&amp; nums1[j] - nums2[i] &lt; min_diff) &#123; min_diff = nums1[j] - nums2[i]; min_diff_idx = j; &#125; if (nums1[j] &lt; min) &#123; min_idx = j; min = nums1[j]; &#125; &#125; &#125; if (min_diff_idx == -1) &#123; res[i] = min; vis[min_idx] = 1; &#125; else &#123; res[i] = nums1[min_diff_idx]; vis[min_diff_idx] = 1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"double_pointer","slug":"double-pointer","permalink":"https://gold-jack.github.io/tags/double-pointer/"},{"name":"greed","slug":"greed","permalink":"https://gold-jack.github.io/tags/greed/"},{"name":"sort","slug":"sort","permalink":"https://gold-jack.github.io/tags/sort/"}]},{"title":"1800.最大升序子数组和","slug":"leetcode/1800.最大升序子数组和","date":"2022-10-06T16:00:00.000Z","updated":"2022-10-07T05:12:06.433Z","comments":true,"path":"2022/10/07/leetcode/1800.最大升序子数组和/","link":"","permalink":"https://gold-jack.github.io/2022/10/07/leetcode/1800.%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","excerpt":"","text":"题目描述1800. 最大升序子数组和难度简单60收藏分享切换为英文接收动态反馈 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例 1： 123输入：nums = [10,20,30,5,10,50]输出：65解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2： 123输入：nums = [10,20,30,40,50]输出：150解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3： 123输入：nums = [12,17,15,13,10,11,12]输出：33解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4： 12输入：nums = [100,10,1]输出：100 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 Java1234567891011121314151617181920class Solution &#123; public int maxAscendingSum(int[] nums) &#123; int max = -1; int sum = 0; int pre = -1; for (int num : nums) &#123; if (num &gt; pre) &#123; sum += num; &#125; else &#123; if (sum &gt; max) max = sum; sum = num; &#125; pre = num; &#125; if (sum &gt; max) max = sum; return max; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[]},{"title":"207.课程表 210.课程表 II","slug":"leetcode/207.课程表-210.课程表-II","date":"2022-10-06T16:00:00.000Z","updated":"2022-10-08T11:15:46.037Z","comments":true,"path":"2022/10/07/leetcode/207.课程表-210.课程表-II/","link":"","permalink":"https://gold-jack.github.io/2022/10/07/leetcode/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8-210.%E8%AF%BE%E7%A8%8B%E8%A1%A8-II/","excerpt":"","text":"207. 课程表难度中等1434收藏分享切换为英文接收动态反馈 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 示例 1： 123输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。 示例 2： 123输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。 提示： 1 &lt;= numCourses &lt;= 105 0 &lt;= prerequisites.length &lt;= 5000 prerequisites[i].length == 2 0 &lt;= ai, bi &lt; numCourses prerequisites[i] 中的所有课程对 互不相同 Java暴力解法12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; Node[] nodes = new Node[numCourses]; for (int i = 0; i &lt; numCourses; i++) nodes[i] = new Node(i); for (int[] pair : prerequisites) &#123; int to_study = pair[0]; int pre_study = pair[1]; nodes[to_study].in_nodes.add(pre_study); nodes[pre_study].out_nodes.add(to_study); &#125; boolean have_empty_in = false; int nums_left = numCourses; do &#123; have_empty_in = false; for (Node node : nodes) &#123; if (!node.in_nodes.isEmpty() || node.vis) continue; have_empty_in = true; nums_left--; int idx = node.val; for (int nn : node.out_nodes) &#123; nodes[nn].in_nodes.remove(new Integer(idx)); &#125; node.vis = true; &#125; &#125; while (have_empty_in &amp;&amp; nums_left &gt; 0); return nums_left == 0; &#125; class Node &#123; int val; boolean vis; ArrayList&lt;Integer&gt; in_nodes = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; out_nodes = new ArrayList&lt;&gt;(); Node() &#123; this.vis = false; &#125; Node(int val) &#123; this.val = val; this.vis = false; &#125; &#125;&#125; 210. 课程表 II难度中等713收藏分享切换为英文接收动态反馈 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 示例 1： 123输入：numCourses = 2, prerequisites = [[1,0]]输出：[0,1]解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2： 1234输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]输出：[0,2,1,3]解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 示例 3： 12输入：numCourses = 1, prerequisites = []输出：[0] 提示： 1 &lt;= numCourses &lt;= 2000 0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1) prerequisites[i].length == 2 0 &lt;= ai, bi &lt; numCourses ai != bi 所有[ai, bi] 互不相同 Java暴力解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Node[] nodes = new Node[numCourses]; for (int i = 0; i &lt; numCourses; i++) nodes[i] = new Node(i); for (int[] pair : prerequisites) &#123; int to_study = pair[0]; int pre_study = pair[1]; nodes[to_study].in_nodes.add(pre_study); nodes[pre_study].out_nodes.add(to_study); &#125; int[] res = new int[numCourses]; boolean have_empty_in = false; int nums_left = numCourses; do &#123; have_empty_in = false; for (Node node : nodes) &#123; if (!node.in_nodes.isEmpty() || node.vis) continue; res[numCourses - nums_left] = node.val; have_empty_in = true; nums_left--; int idx = node.val; for (int nn : node.out_nodes) &#123; nodes[nn].in_nodes.remove(new Integer(idx)); &#125; node.vis = true; &#125; &#125; while (have_empty_in &amp;&amp; nums_left &gt; 0); if (nums_left &gt; 0) return new int[0]; return res; &#125; class Node &#123; int val; boolean vis; ArrayList&lt;Integer&gt; in_nodes = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; out_nodes = new ArrayList&lt;&gt;(); Node() &#123; this.vis = false; &#125; Node(int val) &#123; this.val = val; this.vis = false; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"graph","slug":"graph","permalink":"https://gold-jack.github.io/tags/graph/"}]},{"title":"811.子域名访问计数","slug":"leetcode/811.子域名访问计数","date":"2022-10-06T16:00:00.000Z","updated":"2022-10-07T05:13:42.780Z","comments":true,"path":"2022/10/07/leetcode/811.子域名访问计数/","link":"","permalink":"https://gold-jack.github.io/2022/10/07/leetcode/811.%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/","excerpt":"","text":"811.子域名访问计数题目描述811. 子域名访问计数难度中等173收藏分享切换为英文接收动态反馈 网站域名 &quot;discuss.leetcode.com&quot; 由多个子域名组成。顶级域名为 &quot;com&quot; ，二级域名为 &quot;leetcode.com&quot; ，最低一级为 &quot;discuss.leetcode.com&quot; 。当访问域名 &quot;discuss.leetcode.com&quot; 时，同时也会隐式访问其父域名 &quot;leetcode.com&quot; 以及 &quot;com&quot; 。 计数配对域名 是遵循 &quot;rep d1.d2.d3&quot; 或 &quot;rep d1.d2&quot; 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。 例如，&quot;9001 discuss.leetcode.com&quot; 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。 给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。 示例 1： 1234输入：cpdomains = [&quot;9001 discuss.leetcode.com&quot;]输出：[&quot;9001 leetcode.com&quot;,&quot;9001 discuss.leetcode.com&quot;,&quot;9001 com&quot;]解释：例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。按照前文描述，子域名 &quot;leetcode.com&quot; 和 &quot;com&quot; 都会被访问，所以它们都被访问了 9001 次。 示例 2： 1234输入：cpdomains = [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]输出：[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]解释：按照前文描述，会访问 &quot;google.mail.com&quot; 900 次，&quot;yahoo.com&quot; 50 次，&quot;intel.mail.com&quot; 1 次，&quot;wiki.org&quot; 5 次。而对于父域名，会访问 &quot;mail.com&quot; 900 + 1 = 901 次，&quot;com&quot; 900 + 50 + 1 = 951 次，和 &quot;org&quot; 5 次。 提示： 1 &lt;= cpdomain.length &lt;= 100 1 &lt;= cpdomain[i].length &lt;= 100 cpdomain[i] 会遵循 &quot;repi d1i.d2i.d3i&quot; 或 &quot;repi d1i.d2i&quot; 格式 repi 是范围 [1, 104] 内的一个整数 d1i、d2i 和 d3i 由小写英文字母组成 Java暴力解法12345678910111213141516171819202122class Solution &#123; public List&lt;String&gt; subdomainVisits(String[] cpdomains) &#123; HashMap&lt;String, Integer&gt; visCount = new HashMap&lt;&gt;(); for (String cp : cpdomains) &#123; String[] cntAndDomain = cp.split(&quot; &quot;); int cnt = Integer.parseInt(cntAndDomain[0]); String domain = cntAndDomain[1]; for (int j = 0; j &lt; domain.length(); j++) &#123; if (j == 0 || domain.charAt(j) == &#x27;.&#x27;) &#123; String d = domain.substring(j==0 ? 0 : j+1); visCount.put(d, visCount.getOrDefault(d, 0) + cnt); &#125; &#125; &#125; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for ( String domain : visCount.keySet()) &#123; res.add(visCount.get(domain) + &quot; &quot; + domain); &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"string","slug":"string","permalink":"https://gold-jack.github.io/tags/string/"}]},{"title":"230.二叉搜索树中第K小的元素","slug":"leetcode/230.二叉搜索树中第K小的元素","date":"2022-10-03T16:00:00.000Z","updated":"2022-10-04T10:51:47.145Z","comments":true,"path":"2022/10/04/leetcode/230.二叉搜索树中第K小的元素/","link":"","permalink":"https://gold-jack.github.io/2022/10/04/leetcode/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"230.二叉搜索树中第K小的元素题目描述230. 二叉搜索树中第K小的元素难度中等675收藏分享切换为英文接收动态反馈 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 12输入：root = [3,1,4,null,2], k = 1输出：1 示例 2： 12输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3 提示： 树中的节点数为 n 。 1 &lt;= k &lt;= n &lt;= 104 0 &lt;= Node.val &lt;= 104 进阶：如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？ Java暴力解法12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); midTraverse(root, vals); return vals.get(k - 1); &#125; void midTraverse(TreeNode node, ArrayList&lt;Integer&gt; vals) &#123; if ( node == null ) return; midTraverse(node.left, vals); vals.add(node.val); midTraverse(node.right, vals); return; &#125;&#125; AVL解法不会","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"},{"name":"AVL","slug":"AVL","permalink":"https://gold-jack.github.io/tags/AVL/"}]},{"title":"235.二叉搜索树的最近公共祖先","slug":"leetcode/235.二叉搜索树的最近公共祖先","date":"2022-10-03T16:00:00.000Z","updated":"2022-10-04T10:51:36.990Z","comments":true,"path":"2022/10/04/leetcode/235.二叉搜索树的最近公共祖先/","link":"","permalink":"https://gold-jack.github.io/2022/10/04/leetcode/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"","text":"235.二叉搜索树的最近公共祖先题目描述235. 二叉搜索树的最近公共祖先难度中等942收藏分享切换为英文接收动态反馈 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 Java暴力解法12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return judge(root, p, q); &#125; TreeNode judge(TreeNode node, TreeNode p, TreeNode q) &#123; if ( node == null ) return null; if ( node.val == p.val || node.val == q.val) return node; if ( (node.val &lt; p.val &amp;&amp; node.val &gt; q.val) || (node.val &gt; p.val &amp;&amp; node.val &lt; q.val)) return node; if (node.val &lt; p.val) &#123; return judge(node.right, p, q); &#125; return judge(node.left, p, q); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"}]},{"title":"538.把二叉搜索树转换为累加树","slug":"leetcode/538.把二叉搜索树转换为累加树","date":"2022-10-03T16:00:00.000Z","updated":"2022-10-04T10:52:08.753Z","comments":true,"path":"2022/10/04/leetcode/538.把二叉搜索树转换为累加树/","link":"","permalink":"https://gold-jack.github.io/2022/10/04/leetcode/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","excerpt":"","text":"538.把二叉搜索树转换为累加树题目描述538. 把二叉搜索树转换为累加树难度中等791收藏分享切换为英文接收动态反馈 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 12输入：root = [0,null,1]输出：[1,null,1] 示例 3： 12输入：root = [1,0,2]输出：[3,3,2] 示例 4： 12输入：root = [3,2,4,1]输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 Java暴力解法123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode convertBST(TreeNode root) &#123; ArrayList&lt;TreeNode&gt; nodes = new ArrayList&lt;&gt;(); midTraverse(root, nodes); int greaterSum = 0; for ( int i = nodes.size() - 1; i &gt;= 0; i--) &#123; nodes.get(i).val += greaterSum; greaterSum = nodes.get(i).val; &#125; return root; &#125; void midTraverse(TreeNode node, ArrayList&lt;TreeNode&gt; nodes) &#123; if ( node == null ) return; midTraverse(node.left, nodes); nodes.add(node); midTraverse(node.right, nodes); return; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"}]},{"title":"99.恢复二叉搜索树","slug":"leetcode/99.恢复二叉搜索树","date":"2022-10-03T16:00:00.000Z","updated":"2022-10-04T10:51:53.918Z","comments":true,"path":"2022/10/04/leetcode/99.恢复二叉搜索树/","link":"","permalink":"https://gold-jack.github.io/2022/10/04/leetcode/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"99.恢复二叉搜索树题目描述99. 恢复二叉搜索树难度中等789收藏分享切换为英文接收动态反馈 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。 示例 1： 123输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 123输入：root = [3,1,4,null,null,2]输出：[2,1,4,null,null,3]解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示： 树上节点的数目在范围 [2, 1000] 内 -231 &lt;= Node.val &lt;= 231 - 1 进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？ JavaO(n)空间解法 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void recoverTree(TreeNode root) &#123; ArrayList&lt;TreeNode&gt; vals = new ArrayList&lt;&gt;(); midTraverse(root, vals); for (int i = 0; i &lt; vals.size() - 1; i++) &#123; if ( vals.get(i).val &gt; vals.get(i + 1).val ) &#123; int j = i + 1; while ( j &lt; vals.size() &amp;&amp; vals.get(i).val &gt; vals.get(j).val ) j++; // swap node values int temp = vals.get(i).val; vals.get(i).val = vals.get(j - 1).val; vals.get(j - 1).val = temp; break; &#125; &#125; &#125; void midTraverse(TreeNode node, ArrayList&lt;TreeNode&gt; list) &#123; if ( node == null ) return; midTraverse(node.left, list); list.add(node); midTraverse(node.right, list); return; &#125;&#125; O(1)空间解法暂时没想到","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"}]},{"title":"1.两数之和","slug":"leetcode/1.两数之和","date":"2022-10-02T16:00:00.000Z","updated":"2022-10-15T03:19:30.216Z","comments":true,"path":"2022/10/03/leetcode/1.两数之和/","link":"","permalink":"https://gold-jack.github.io/2022/10/03/leetcode/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"1. 两数之和难度简单15470收藏分享切换为英文接收动态反馈 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ Java哈希表解法时间复杂度O(n) 12345678910111213141516class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; hashTable = new HashMap&lt;&gt;(); for ( int i = 0; i &lt; nums.length; i++) &#123; if ( hashTable.containsKey(target - nums[i]) ) &#123; int[] res = new int[2]; res[0] = hashTable.get(target - nums[i]); res[1] = i; return res; &#125; else &#123; hashTable.put(nums[i], i); &#125; &#125; return new int[2]; &#125;&#125; 暴力解法时间复杂度O(n^2) 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for ( int i = 0; i &lt; nums.length - 1; i++ ) &#123; for ( int j = i + 1; j &lt; nums.length; j++ ) &#123; if ( nums[i] + nums[j] == target) &#123; int[] res = new int[2]; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return new int[2]; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"hash_table","slug":"hash-table","permalink":"https://gold-jack.github.io/tags/hash-table/"}]},{"title":"2.两数相加","slug":"leetcode/2.两数相加","date":"2022-10-01T16:00:00.000Z","updated":"2022-10-03T03:31:51.773Z","comments":true,"path":"2022/10/02/leetcode/2.两数相加/","link":"","permalink":"https://gold-jack.github.io/2022/10/02/leetcode/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"2.两数相加题目描述2. 两数相加难度中等8727收藏分享切换为英文接收动态反馈 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 Java我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode base = l1; ListNode toAdd = l2; int i = 0, j = 0; while ( base != null) &#123; i++; base = base.next; &#125; while ( toAdd != null) &#123; j++; toAdd = toAdd.next; &#125; ListNode res = new ListNode(); if ( j &gt; i) &#123; res = l2; base = l2; toAdd = l1; &#125; else &#123; res = l1; base = l1; toAdd = l2; &#125; int exceed = 0; while ( base != null ) &#123; if ( toAdd != null ) &#123; int addRes = base.val + toAdd.val + exceed; base.val = addRes % 10; exceed = addRes / 10; if ( toAdd.next != null) toAdd = toAdd.next; else toAdd = null; &#125; else &#123; int addRes = base.val + exceed; base.val = addRes % 10; exceed = addRes / 10; &#125; if ( base.next != null) base = base.next; else break; &#125; if ( exceed != 0) base.next = new ListNode(exceed); return res; &#125;&#125; 官方解法 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null, tail = null; int exceed = 0; while ( l1 != null || l2 != null) &#123; int val_1 = l1 == null ? 0 : l1.val; int val_2 = l2 == null ? 0 : l2.val; int tmp_sum = val_1 + val_2 + exceed; if ( head == null) &#123; head = tail = new ListNode(tmp_sum % 10); &#125; else &#123; tail.next = new ListNode(tmp_sum % 10); tail = tail.next; &#125; exceed = tmp_sum / 10; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if ( exceed != 0 ) tail.next = new ListNode(exceed); return head; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"big_int","slug":"big-int","permalink":"https://gold-jack.github.io/tags/big-int/"}]},{"title":"777.在LR字符串中交换相邻字符","slug":"leetcode/777.在LR字符串中交换相邻字符","date":"2022-10-01T16:00:00.000Z","updated":"2022-10-02T09:01:52.712Z","comments":true,"path":"2022/10/02/leetcode/777.在LR字符串中交换相邻字符/","link":"","permalink":"https://gold-jack.github.io/2022/10/02/leetcode/777.%E5%9C%A8LR%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/","excerpt":"","text":"777.在LR字符串中交换相邻字符题目描述777. 在LR字符串中交换相邻字符难度中等213收藏分享切换为英文接收动态反馈 在一个由 &#39;L&#39; , &#39;R&#39; 和 &#39;X&#39; 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 示例 : 123456789输入: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;输出: True解释:我们可以通过以下几步将start转换成end:RXXLRXRXL -&gt;XRXLRXRXL -&gt;XRLXRXRXL -&gt;XRLXXRRXL -&gt;XRLXXRRLX 提示： 1 &lt;= len(start) = len(end) &lt;= 10000。 start和end中的字符串仅限于&#39;L&#39;, &#39;R&#39;和&#39;X&#39;。 Java暴力解法12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean canTransform(String start, String end) &#123; if (!start.replaceAll(&quot;X&quot;, &quot;&quot;).equals(end.replaceAll(&quot;X&quot;, &quot;&quot;))) return false; int[] start_X_num = new int[start.replaceAll(&quot;X&quot;, &quot;&quot;).length()]; int[] end_X_num = new int[end.replaceAll(&quot;X&quot;, &quot;&quot;).length()]; get_num(start, start_X_num); get_num(end, end_X_num); String s_without_X = start.replaceAll(&quot;X&quot;, &quot;&quot;); for ( int i = 0; i &lt; start_X_num.length; i++) &#123; if ( s_without_X.charAt(i) == &#x27;R&#x27; &amp;&amp; start_X_num[i] &gt; end_X_num[i]) return false; else if ( s_without_X.charAt(i) == &#x27;L&#x27; &amp;&amp; start_X_num[i] &lt; end_X_num[i]) return false; &#125; return true; &#125; private void get_num(String s, int[] num) &#123; int p = 0; for ( int i = 0; i &lt; s.length(); i++) &#123; if ( s.charAt(i) == &#x27;X&#x27; ) continue; int cnt = 0; int j = i - 1; while(j &gt;= 0) &#123; if ( s.charAt(j) == &#x27;X&#x27; ) cnt++; j--; &#125; num[p++] = cnt; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"find_patterns","slug":"find-patterns","permalink":"https://gold-jack.github.io/tags/find-patterns/"},{"name":"string","slug":"string","permalink":"https://gold-jack.github.io/tags/string/"}]},{"title":"98. 验证二叉搜索树","slug":"leetcode/98.-验证二叉搜索树","date":"2022-09-30T16:00:00.000Z","updated":"2022-10-01T10:22:01.650Z","comments":true,"path":"2022/10/01/leetcode/98.-验证二叉搜索树/","link":"","permalink":"https://gold-jack.github.io/2022/10/01/leetcode/98.-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"98.验证二叉搜索树题目描述98. 验证二叉搜索树难度中等1763收藏分享切换为英文接收动态反馈 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 12输入：root = [2,1,3]输出：true 示例 2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 Java利用中序遍历求解 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; ArrayList&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); public boolean isValidBST(TreeNode root) &#123; if ( root == null) return true; midTraverse(root); for (int i = 0; i &lt; vals.size() - 1; i++) &#123; if ( !(vals.get(i) &lt; vals.get(i + 1)) ) return false; &#125; return true; &#125; private void midTraverse(TreeNode node) &#123; if (node == null) return; midTraverse(node.left); vals.add(node.val); midTraverse(node.right); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"},{"name":"traverse","slug":"traverse","permalink":"https://gold-jack.github.io/tags/traverse/"}]},{"title":"面试题 01.08. 零矩阵","slug":"leetcode/面试题-01.08.-零矩阵","date":"2022-09-29T16:00:00.000Z","updated":"2022-09-30T08:27:18.630Z","comments":true,"path":"2022/09/30/leetcode/面试题-01.08.-零矩阵/","link":"","permalink":"https://gold-jack.github.io/2022/09/30/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-01.08.-%E9%9B%B6%E7%9F%A9%E9%98%B5/","excerpt":"","text":"面试题 01.08. 零矩阵题目描述面试题 01.08. 零矩阵难度中等115收藏分享切换为英文接收动态反馈 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1： 123456789101112输入：[ [1,1,1], [1,0,1], [1,1,1]]输出：[ [1,0,1], [0,0,0], [1,0,1]] 示例 2： 123456789101112输入：[ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出：[ [0,0,0,0], [0,4,5,0], [0,3,1,0]] Java 123456789101112131415161718192021222324class Solution &#123; public void setZeroes(int[][] matrix) &#123; findAll(matrix, 0, 0); &#125; private void findAll(int[][] matrix, int x, int y) &#123; boolean funFind = false; int j = y; for (int i = x; i &lt; matrix.length &amp;&amp; !funFind; i++) &#123; while( j &lt; matrix[0].length &amp;&amp; !funFind) &#123; if (matrix[i][j] == 0) &#123; funFind = true; findAll(matrix, i, j+1); for ( int p = 0; p &lt; matrix[0].length; p++) matrix[i][p] = 0; for ( int q = 0; q &lt; matrix.length; q++) matrix[q][j] = 0; &#125; j++; &#125; j = 0; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"面试题 01.09. 字符串轮转","slug":"leetcode/面试题-01.09.-字符串轮转","date":"2022-09-29T16:00:00.000Z","updated":"2022-09-30T08:35:48.958Z","comments":true,"path":"2022/09/30/leetcode/面试题-01.09.-字符串轮转/","link":"","permalink":"https://gold-jack.github.io/2022/09/30/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-01.09.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/","excerpt":"","text":"面试题 01.09. 字符串轮转题目描述面试题 01.09. 字符串轮转难度简单212收藏分享切换为英文接收动态反馈 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。 示例1: 12输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;输出：True 示例2: 12输入：s1 = &quot;aa&quot;, s2 = &quot;aba&quot;输出：False Java暴力解法时间复杂度为O(n) 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isFlipedString(String s1, String s2) &#123; if ( s1.length() == 0 &amp;&amp; s2.length() == 0) return true; if ( s1.length() != s2.length() ) return false; for ( int i = 0; i &lt; s2.length(); i++) &#123; if ( s2.charAt(i) == s1.charAt(0) ) &#123; if ( isMatch(s1, s2, i) ) return true; &#125; &#125; return false; &#125; private boolean isMatch(String s1, String s2, int s2_idx) &#123; boolean flag = true; for ( int i = 0; i &lt; s1.length(); i++) &#123; if ( s1.charAt(i) != s2.charAt(s2_idx)) &#123; flag = false; break; &#125; s2_idx++; s2_idx = s2_idx % s2.length(); &#125; return flag; &#125;&#125; 判断s1+s1是否包含s2子串（评论区解法）时间、空间复杂度均为O(n) 12345class Solution &#123; public boolean isFlipedString(String s1, String s2) &#123; return s1.length() == s2.length() &amp;&amp; (s1 + s1).contains(s2); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"substring","slug":"substring","permalink":"https://gold-jack.github.io/tags/substring/"}]},{"title":"17.电话号码的字母组合","slug":"leetcode/17.电话号码的字母组合","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T10:16:57.630Z","comments":true,"path":"2022/09/28/leetcode/17.电话号码的字母组合/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/leetcode/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"","text":"17.电话号码的字母组合问题描述17. 电话号码的字母组合难度中等2126收藏分享切换为英文接收动态反馈 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 12输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] 示例 2： 12输入：digits = &quot;&quot;输出：[] 示例 3： 12输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 解法一：暴力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; String[] digit9 = new String[10]; private void init() &#123; digit9[2] = &quot;abc&quot;; digit9[3] = &quot;def&quot;; digit9[4] = &quot;ghi&quot;; digit9[5] = &quot;jkl&quot;; digit9[6] = &quot;mno&quot;; digit9[7] = &quot;pqrs&quot;; digit9[8] = &quot;tuv&quot;; digit9[9] = &quot;wxyz&quot;; &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; init(); String[] pace = new String[4]; if (digits.length() == 0) &#123; return new ArrayList&lt;&gt;(); &#125; for (int i = 0; i &lt; digits.length(); i++) &#123; pace[i] = digit9[digits.charAt(i) - &#x27;0&#x27;]; &#125;// System.out.println(&quot;pace = &quot; + pace[2]); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int a0 = 0; pace[0] != null &amp;&amp; a0 &lt; pace[0].length(); a0++) &#123; String temp = String.valueOf(pace[0].charAt(a0)); list.add(temp); for (int a1 = 0; pace[1] != null &amp;&amp; a1 &lt; pace[1].length(); a1++) &#123; temp += String.valueOf(pace[1].charAt(a1)); list.add(temp); for (int a2 = 0; pace[2] != null &amp;&amp; a2 &lt; pace[2].length(); a2++) &#123; temp += String.valueOf(pace[2].charAt(a2)); list.add(temp); for (int a3 = 0; pace[3] != null &amp;&amp; a3 &lt; pace[3].length(); a3++) &#123; temp += String.valueOf(pace[3].charAt(a3)); list.add(temp); temp = temp.substring(0, 3); &#125; temp = temp.substring(0, 2); &#125; temp = temp.substring(0, 1); &#125; &#125; list.removeIf(s -&gt; s.length() != digits.length()); return list; &#125;&#125; 解法二：DFS","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://gold-jack.github.io/tags/DFS/"}]},{"title":"46.全排列 47.全排列Ⅱ","slug":"leetcode/46.全排列","date":"2022-09-27T16:00:00.000Z","updated":"2022-10-08T11:08:14.951Z","comments":true,"path":"2022/09/28/leetcode/46.全排列/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/leetcode/46.%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"46.全排列问题描述46. 全排列难度中等 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 Java123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; int[] vis = new int[nums.length]; tree(nums, res, arr, vis); return res; &#125; private void tree(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; arr, int[] vis) &#123; if (arr.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(arr)); return ; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if ( vis[i] == 1) continue; vis[i] = 1; arr.add(nums[i]); tree(nums, res, arr, vis); vis[i] = 0; arr.remove(arr.size() - 1); &#125; &#125;&#125; 47.全排列Ⅱ问题描述47. 全排列 II难度中等 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 示例 2： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 Java12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; int[] vis = new int[nums.length]; tree(nums, res, arr, vis); HashSet&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); set.addAll(res); List&lt;List&lt;Integer&gt;&gt; unique = new ArrayList&lt;&gt;(); unique.addAll(set); return unique; &#125; private void tree(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; arr, int[] vis) &#123; if (arr.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(arr)); return ; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if ( vis[i] == 1) continue; vis[i] = 1; arr.add(nums[i]); tree(nums, res, arr, vis); vis[i] = 0; arr.remove(arr.size() - 1); &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"47.全排列Ⅱ","slug":"leetcode/47.全排列Ⅱ","date":"2022-09-27T16:00:00.000Z","updated":"2022-10-08T11:07:23.653Z","comments":true,"path":"2022/09/28/leetcode/47.全排列Ⅱ/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/leetcode/47.%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1/","excerpt":"","text":"","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"}]},{"title":"AirportManagement Project","slug":"notes/Airport-Management","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:44:20.474Z","comments":true,"path":"2022/09/28/notes/Airport-Management/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Airport-Management/","excerpt":"","text":"Airport-Management-1.3.0 参考视频&amp;文档链接： 从零手撸springboot-vue后台管理系统—青戈：https://www.bilibili.com/video/BV1U44y1W77D?p=18&amp;vd_source=ac1b24359a7d27b63248ae1c80f2ba6c vue上手教程—狂神：https://www.bilibili.com/video/BV18E411a7mC?spm_id_from=333.337.search-card.all.click&amp;vd_source=ac1b24359a7d27b63248ae1c80f2ba6c Mybatis-Plus代码生成器 Vue项目初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 在管理员模式下启动cmd# 进入项目根目录C:\\Windows\\system32&gt;cd E:IDEA-Workspace# 使用 vue create &lt;PROJECT_NAME&gt; 初始化项目E:\\IDEA-Workspace\\airport-management&gt;vue create project-nameVue CLI v5.0.8? Please pick a preset: vue3-without-eslint ([Vue 3] babel, router, vuex) Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint)&gt; Manually select features # 选择手动配置，按enter下一步# 下一步# 使用space键勾选配置? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and&lt;enter&gt; to proceed) (*) Babel # babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router # vue-router (*) Vuex # vuex ( ) CSS Pre-processors&gt;( ) Linter / Formatter # 暂时不选eslint，防止代码检查报错 ( ) Unit Testing ( ) E2E Testing # 下一步? Choose a version of Vue.js that you want to start the project with (Use arrow keys)&gt; 3.x # 选择vue3 2.x # 下一步#使用history mode for router? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files&gt; In package.json # 选择在package.json中放置babel,eslint等配置文件# 下一步? Save this as a preset for future projects? (y/N) # 是否希望将上述配置保存为一个预设文件，均可# 项目开始自动初始化✨ Creating project in E:\\IDEA-Workspace\\airport-management\\project-name.⚙️ Installing CLI plugins. This might take a while...# 初始化完成后cd &lt;PROJECT_NAME&gt;cnpm run serve# 访问localhost:8080可以看到vue的helloworld界面# 至此，vue3的基础项目创建成功 Element-plus官网：https://element-plus.org/zh-CN/ 123# 安装（详见官网指南）cnpm install element-plus -S # -S代表本地安装开发环境，即--save-devcnpm install 12345// 在vue项目中的main.js中引入element-plusimport ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;app.use(ElementPlus) Axios官网：https://axios-http.com/ 123# 安装cnpm install axios -Scnpm install Request.js 和 vue.config.js request.js 一般放在src&#x2F;utils&#x2F;文件夹下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import axios from &#x27;axios&#x27;import router from &quot;@/router&quot;;import &#123;ElMessage&#125; from &quot;element-plus&quot;;const request = axios.create(&#123; baseURL: &#x27;/universal-prefix&#x27;, // 这里是全局统一加上了 &#x27;/universal-prefix&#x27; 前缀 // 也就是说所有接口都会加上&#x27;/universal-prefix&#x27;前缀，在页面里面写接口的时候就不要加 &#x27;/universal-prefix&#x27;了，否则会出现2个&#x27;/universal-prefix&#x27;，类似 &#x27;/universal-prefix/universal-prefix/user&#x27;这样的报错，切记！！！ timeout: 5000&#125;)// 请求白名单，如果请求在白名单里面，将不会被拦截校验权限const whiteUrls = [&quot;/login&quot;, &#x27;/register&#x27;]// request 拦截器// 可以自请求发送前对请求做一些处理// 比如统一加token，对请求参数统一加密request.interceptors.request.use(config =&gt; &#123; config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=utf-8&#x27;; let loginUserJson = sessionStorage.getItem(&quot;loginUser&quot;); if (!whiteUrls.includes(config.url)) &#123; // 如果url不在白名单里，就要进行拦截 if ( loginUserJson == null) &#123; // 如果loginUserJson为空， router.push(&quot;/login&quot;).then(res =&gt; &#123; // 则说明用户未登陆，则跳转至登陆界面 ElMessage(&quot;请先登录，再访问界面&quot;); &#125;); &#125; else &#123; let user = JSON.parse(loginUserJson); // 如果获取了用户信息 config.headers[&#x27;token&#x27;] = user.token; // 则设置请求头，添加登陆用户token信息 &#125; &#125; return config&#125;, error =&gt; &#123; return Promise.reject(error)&#125;);// response 拦截器 // response拦截器一般是固定格式，可以直接复制// 可以在接口响应后统一处理结果request.interceptors.response.use( response =&gt; &#123; let res = response.data; // 如果是返回的文件 if (response.config.responseType === &#x27;blob&#x27;) &#123; return res &#125; // 兼容服务端返回的字符串数据 if (typeof res === &#x27;string&#x27;) &#123; res = res ? JSON.parse(res) : res &#125; // console.log(res.code); return res; &#125;, error =&gt; &#123; console.log(&#x27;err&#x27; + error) // for debug return Promise.reject(error) &#125;)export default request vue.config.js 一般放在&#x2F;src文件夹下 12345678910111213141516171819const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; // transpileDependencies: true, devServer: &#123; //记住，别写错了devServer//设置本地默认端口 选填 // disableHostCheck: true, port: 9000, proxy: &#123; //设置代理，必须填 &#x27;/universal-prefix&#x27;: &#123; //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: &#x27;http://localhost:9090&#x27;, //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: &#123; //路径重写 &#x27;^/universal-prefix&#x27;: &#x27;&#x27; //选择忽略拦截器里面的内容 &#125; &#125; &#125;, &#125;&#125;) 登陆 &#x2F; 注册 login.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div style=&quot;width: 400px; margin: 150px auto; background-color: white; border-radius: 25px&quot;&gt; &lt;div style=&quot;font-size: 30px; text-align: center; padding: 30px 0&quot;&gt;欢迎登陆&lt;/div&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; style=&quot;padding: 0 50px 50px 50px&quot; size=&quot;large&quot;&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;!--这里的prefix-icon功能未实现--&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; placeholder=&quot;请输入密码&quot; show-password /&gt; &lt;/el-form-item&gt; &lt;el-form-item style=&quot;width: 100%; display: flex&quot;&gt; &lt;!--注册这里@click必须用$router.push直接跳转，不能用函数，否则会出现token认证错误，原因不明--&gt; &lt;el-button type=&quot;primary&quot; style=&quot;flex: 1&quot; @click=&quot;$router.push(&#x27;/register&#x27;)&quot;&gt;注册&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; style=&quot;flex: 1&quot; @click=&quot;login&quot;&gt;登陆&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import request from &quot;@/utils/request&quot;;import &#123;ElMessage&#125; from &quot;element-plus&quot;;export default &#123; name: &quot;Login&quot;, data() &#123; return &#123; form: &#123;&#125;, rules: &#123; // element-plus特有的，自动对&lt;el-form&gt;中的属性进行校验 username: [ &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;, ], password: [ &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;, ], &#125; &#125; &#125;, setup() &#123; &#125;, methods: &#123; login() &#123; this.$refs[&#x27;form&#x27;].validate((valid) =&gt; &#123; // 这里的validate方法与上面的:rules对应 if (valid) &#123; // 如果rules验证通过 request.post(&quot;/login&quot;, this.form).then(res =&gt; &#123; // 发送post请求后台登陆 if (res.code === &#x27;CODE_200&#x27;) &#123; ElMessage.success(&quot;登陆成功&quot;); sessionStorage.setItem(&quot;loginUser&quot;, JSON.stringify(res.data)); // console.log(sessionStorage.getItem(&quot;loginUser&quot;)); this.$router.push(&quot;/&quot;); // 如果登陆成功，路由至主页面 &#125; else &#123; ElMessage.error(res.msg); &#125; &#125;) // then &#125; &#125;) // validate &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.wrapper &#123; width: 100%; height: 100vh; background-image: linear-gradient( to bottom right, #FC466B, #3F5EFB); overflow: hidden;&#125;&lt;/style&gt; register.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div style=&quot;width: 400px; margin: 150px auto; background-color: white; border-radius: 25px&quot;&gt; &lt;div style=&quot; font-size: 30px; text-align: center; padding: 30px 0&quot;&gt;注册&lt;/div&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; style=&quot;padding: 0 50px 50px 50px&quot; size=&quot;large&quot;&gt; &lt;el-form-item prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;请输入账号&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; placeholder=&quot;请输入密码&quot; show-password /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;confirm&quot;&gt; &lt;el-input v-model=&quot;form.confirm&quot; placeholder=&quot;请再次输入密码&quot; show-password /&gt; &lt;/el-form-item&gt; &lt;el-form-item style=&quot;width: 100%; display: flex&quot;&gt; &lt;el-button type=&quot;primary&quot; style=&quot;flex: 1&quot; @click=&quot;register&quot;&gt;注册&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; style=&quot;flex: 1&quot; @click=&quot;$router.push(&#x27;/login&#x27;)&quot;&gt;返回登陆&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Lock, UserFilled &#125; from &#x27;@element-plus/icons-vue&#x27;import request from &quot;@/utils/request&quot;;import &#123;ElMessage&#125; from &quot;element-plus&quot;;export default &#123; name: &quot;Register&quot;, data() &#123; return &#123; form: &#123;&#125;, rules: &#123; username: [ &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;, ], password: [ &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;, ], confirm: [ &#123; required: true, message: &#x27;请再次输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;, ], &#125; &#125; &#125;, setup() &#123; return &#123; Lock, UserFilled &#125; &#125;, methods: &#123; register() &#123; this.$refs[&#x27;form&#x27;].validate((valid) =&gt; &#123; if (valid) &#123; if (this.form.password !== this.form.confirm) &#123; ElMessage.error(&quot;两次密码输入不一致，请重新输入&quot;); this.form = &#123;&#125;; &#125; else &#123; request.post(&quot;/register&quot;, this.form).then(res =&gt; &#123; if (res.code === &#x27;CODE_200&#x27; ) &#123; ElMessage.success(&quot;注册成功，请重新登陆&quot;); this.$router.push(&quot;/login&quot;); &#125; else &#123; ElMessage.error(res.msg); this.form = &#123;&#125;; &#125; &#125;) &#125; // else &#125; &#125;) // validate &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.wrapper &#123; width: 100%; height: 100vh; background-image: linear-gradient(to bottom right, #3F5EFB, #fff06c); overflow: hidden&#125;&lt;/style&gt; 员工管理 EmployeeManagement.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;template&gt; &lt;div class=&quot;home&quot; style=&quot;padding: 15px&quot;&gt; &lt;!--功能区域--&gt; &lt;div style=&quot;margin: 10px 0&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;add&quot;&gt;新增&lt;/el-button&gt;&lt;!-- &lt;el-button type=&quot;primary&quot;&gt;导入&lt;/el-button&gt;--&gt; &lt;!-- &lt;el-button type=&quot;primary&quot;&gt;导出&lt;/el-button&gt;--&gt; &lt;/div&gt; &lt;!--搜索区域--&gt; &lt;div style=&quot;margin: 10px 0&quot;&gt; &lt;el-input v-model=&quot;search&quot; placeholder=&quot;输入姓名关键字&quot; style=&quot;width: 20%&quot; clearable&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; style=&quot;margin-left: 10px&quot; @click=&quot;load&quot;&gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;!--数据区域--&gt; &lt;el-table :data=&quot;tableData&quot; border stripe :empty-text=&quot;tableEmptyText&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;employeeId&quot; label=&quot;ID&quot; width=&quot;180&quot; sortable/&gt; &lt;el-table-column prop=&quot;employeeName&quot; label=&quot;姓名&quot; /&gt; &lt;el-table-column prop=&quot;age&quot; label=&quot;年龄&quot; sortable /&gt; &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; /&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; /&gt; &lt;el-table-column prop=&quot;authority&quot; label=&quot;权限&quot; /&gt; &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;140&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;!-- 注意：新版本下，&lt;el-table&gt;当前行的索引用scope.$index获取 --&gt; &lt;el-button type=&quot;default&quot; size=&quot;small&quot; @click=&quot;handleEdit(scope.row)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-popconfirm title=&quot;确认删除吗？&quot; @confirm=&quot;handleDelete(scope.$index)&quot;&gt; &lt;template #reference&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--分页--&gt; &lt;div style=&quot;margin: 10px 0&quot;&gt;&lt;!-- 简洁分页样式--&gt; &lt;div class=&quot;demo-pagination-block&quot;&gt; &lt;el-pagination v-model:currentPage=&quot;currentPage&quot; v-model:page-size=&quot;pageSize&quot; :small=&quot;small&quot; :disabled=&quot;disabled&quot; :background=&quot;background&quot; layout=&quot;prev, pager, next, jumper&quot; :total=&quot;total&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt;&lt;!-- 完整分页样式--&gt;&lt;!-- &lt;el-pagination--&gt;&lt;!-- v-model:currentPage=&quot;currentPage&quot;--&gt;&lt;!-- v-model:page-size=&quot;pageSize&quot;--&gt;&lt;!-- :page-sizes=&quot;[5, 10, 20]&quot;--&gt;&lt;!-- :small=&quot;small&quot;--&gt;&lt;!-- :disabled=&quot;disabled&quot;--&gt;&lt;!-- :background=&quot;background&quot;--&gt;&lt;!-- layout=&quot;total, sizes, prev, pager, next, jumper&quot;--&gt;&lt;!-- :total=&quot;total&quot;--&gt;&lt;!-- @size-change=&quot;handleSizeChange&quot;--&gt;&lt;!-- @current-change=&quot;handleCurrentChange&quot;--&gt;&lt;!-- /&gt;--&gt; &lt;/div&gt; &lt;el-dialog v-model=&quot;dialogVisible&quot; width=&quot;30%&quot;&gt; &lt;el-form :model=&quot;form&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; style=&quot;width: 80%&quot;&gt; &lt;el-input v-model=&quot;form.employeeName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; style=&quot;width: 80%&quot;&gt; &lt;el-input v-model=&quot;form.age&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;性别&quot; style=&quot;width:100%&quot;&gt; &lt;el-radio v-model=&quot;form.sex&quot; label=&quot;男&quot; &gt;男&lt;/el-radio&gt; &lt;el-radio v-model=&quot;form.sex&quot; label=&quot;女&quot; &gt;女&lt;/el-radio&gt; &lt;el-radio v-model=&quot;form.sex&quot; label=&quot;保密&quot; &gt;保密&lt;/el-radio&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;地址&quot; style=&quot;width: 80%&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.address&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;template #footer&gt; &lt;span class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;cancelAdd&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;persistence&quot;&gt;确认&lt;/el-button&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 以下设置用于调整分页样式 --&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const small = ref(true) // 是否使用小分页按钮const background = ref(true) // 分页按钮是否加入背景const disabled = ref(false) // 分页是否不点击&lt;/script&gt;&lt;script&gt;// @ is an alias to /srcimport request from &quot;@/utils/request&quot;;import &#123;ElMessage&#125; from &quot;element-plus&quot;;export default &#123; name: &#x27;EmployeeManagement&#x27;, components: &#123; &#125;, data() &#123; return &#123; search: &#x27;&#x27;, // 用于保存搜索框中的输入 currentPage: 1, // 当前是第几页 pageSize: 10, // 每页有多少条记录 total: 10, // 共有多少页，后端Page组件可以自动计算 dialogVisible: false, // 用于控制弹窗（新增、编辑） form: &#123;&#125;, tableData: [], tableEmptyText: &#x27;没有查询到数据&#x27;, &#125; &#125;, created() &#123; this.load(); &#125;, methods: &#123; MsgByRes(res) &#123; console.log(res); if (res.code === &quot;CODE_200&quot;) &#123; // 后端ResponseCode.CODE_200表示业务成功 ElMessage.success(&quot;更新成功&quot;); &#125; else &#123; ElMessage.error(&quot;更新失败&quot;) &#125; this.load(); &#125;, add() &#123; this.dialogVisible = true; this.form = &#123;&#125;; &#125;, cancelAdd() &#123; this.dialogVisible = false; this.form = &#123;&#125;; &#125;, persistence() &#123; this.dialogVisible = false; if (this.form.employeeId != null) &#123; // id 不为null，说明form是更新请求 request.put(&quot;/employee/management/update&quot;, this.form).then(res =&gt; &#123; this.MsgByRes(res); &#125;) &#125; else &#123; // id 为null，说明form是新增请求 request.post(&quot;/employee/management/persistence&quot;, this.form).then(res =&gt; &#123; this.MsgByRes(res); &#125;); &#125; &#125;, load() &#123; let auth = sessionStorage.getItem(&quot;loginUser&quot;) ? JSON.parse(sessionStorage.getItem(&quot;loginUser&quot;)).authority : &quot;GUEST&quot; request.get(&quot;/employee/management/load&quot;, &#123; params: &#123; // 后端如果申明@RequestParam，则这里的axios格式为： auth: auth, // request.get(&quot;/&lt;URL&gt;&quot;, &#123; params: &#123; key1: value1, key2: value2 &#125;&#125;) pageNum: this.currentPage, pageSize: this.pageSize, search: this.search &#125; &#125;).then(res =&gt; &#123; if (res.code === &#x27;CODE_320&#x27;) &#123; // 如果是因为权限不足没有数据的话，提示没有权限 this.tableEmptyText = &#x27;没有权限内的数据&#x27;; &#125; this.tableData = res.data.records; this.total = res.data.total; &#125;) &#125;, handleEdit(row) &#123; console.log(row) this.form = JSON.parse(JSON.stringify(row)); // 深拷贝 this.dialogVisible = true; &#125;, handleDelete(rowId) &#123; // console.log(&quot;rowId:&quot; + rowId); request.delete(&quot;/employee/management/&quot; + rowId).then(res =&gt; &#123; this.MsgByRes(res); &#125;) &#125;, handleSizeChange() &#123; this.load(); &#125;, handleCurrentChange() &#123; this.load(); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 主页布局 layout.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;!-- 头部--&gt; &lt;Header /&gt; &lt;!-- 主体--&gt; &lt;div style=&quot;display: flex&quot;&gt; &lt;!-- 侧边栏--&gt; &lt;Aside /&gt; &lt;!-- 内容区域--&gt; &lt;router-view style=&quot;flex: 1; height: calc(100vh - 50px)&quot; /&gt; &lt;!-- 负责显示主要内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from &quot;@/components/Header&quot;;import Aside from &quot;@/components/Aside&quot;;export default &#123; name: &#x27;Layout&#x27;, components: &#123; Header, Aside, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Aside 和 Header Aside.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;el-menu style=&quot;min-width: 200px; min-height: calc(100vh - 50px);&quot; default-active=&quot;/home&quot; router class=&quot;el-menu-vertical-demo&quot;&gt; &lt;el-menu-item index=&quot;/home&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-sub-menu index=&quot;2&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Platform /&gt;&lt;/el-icon&gt; &lt;span&gt;管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;/employee/management&quot; &gt;用户管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/plane/management&quot; &gt;飞机管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/track/management&quot; &gt;跑道管理&lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item index=&quot;/person&quot;&gt; &lt;el-icon&gt;&lt;Avatar /&gt;&lt;/el-icon&gt; &lt;span&gt;个人信息&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; Document, Menu as IconMenu, Location, Setting, Platform, Avatar,&#125; from &#x27;@element-plus/icons-vue&#x27;&lt;/script&gt;&lt;script&gt;export default &#123; name: &quot;Aside&quot;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Header.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div style=&quot;height: 50px; line-height: 50px; border-bottom: 1px solid #ccc; display: flex&quot;&gt; &lt;div style=&quot;width: 200px; padding-left: 30px; font-weight: bold; color: dodgerblue;&quot;&gt;机场管理系统后台&lt;/div&gt; &lt;div style=&quot;flex: 1&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width: 10%; padding-top: 18px&quot;&gt; &lt;el-dropdown style=&quot;color: midnightblue; &quot;&gt; &lt;span class=&quot;el-dropdown-link&quot; style=&quot;display: flex&quot;&gt; &lt;div style=&quot;flex: 1&quot;&gt;&#123;&#123; user.employeeName &#125;&#125;&lt;/div&gt; &lt;el-icon class=&quot;el-icon--right&quot; style=&quot;width: 15%&quot;&gt; &lt;arrow-down /&gt; &lt;/el-icon&gt; &lt;/span&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu&gt; &lt;el-dropdown-item @click=&quot;$router.push(&#x27;/person&#x27;)&quot;&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item @click=&quot;$router.push(&#x27;/login&#x27;)&quot;&gt;退出系统&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ArrowDown &#125; from &#x27;@element-plus/icons-vue&#x27;&lt;/script&gt;&lt;script&gt;export default &#123; name: &quot;Header&quot;, data() &#123; return &#123; user: sessionStorage.getItem(&quot;loginUser&quot;) ? JSON.parse(sessionStorage.getItem(&quot;loginUser&quot;)) : &#123;&#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.example-showcase .el-dropdown-link &#123; cursor: pointer; color: var(--el-color-primary); display: flex; align-items: center;&#125;&lt;/style&gt; 路由 router&#x2F;index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Layout&#x27;, redirect: &#x27;/home&#x27;, // 重定向至/home菜单 component: () =&gt; import(&quot;@/layout/Layout&quot;), children: [ &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&quot;@/views/Home&quot;) &#125;, &#123; path: &#x27;/person&#x27;, name: &#x27;Person&#x27;, component: () =&gt; import(&quot;@/views/Person&quot;) &#125;, // 左侧管理类菜单路由 &#123; // 雇员管理 path: &#x27;/employee/management&#x27;, name: &#x27;EmployeeManagement&#x27;, component: () =&gt; import(&quot;@/views/management/EmployeeManagement&quot;) &#125;, &#123; // 飞机管理 path: &#x27;/plane/management&#x27;, name: &#x27;PlaneManagement&#x27;, component: () =&gt; import(&quot;@/views/management/PlaneManagement&quot;) &#125;, &#123; // 跑道管理 path: &#x27;/track/management&#x27;, name: &#x27;TrackManagement&#x27;, component: () =&gt; import(&quot;@/views/management/TrackManagement&quot;) &#125; ] &#125;, &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: () =&gt; import(&quot;@/views/login-view/Login&quot;), // Lazy Loading &#125;, &#123; path: &#x27;/register&#x27;, name: &#x27;Register&#x27;, component: () =&gt; import(&quot;@/views/login-view/Register&quot;), &#125;,]const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes&#125;)export default router App.vue 和 main.js App.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; main.js 123456789101112131415import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import &#x27;@/assets/css/global.css&#x27; // 一般放在/src/assests/css里createApp(App) .use(store) .use(router) .use(ElementPlus) .mount(&#x27;#app&#x27;) global.css 12345* &#123; margin: 0; padding: 0; box-sizing: border-box;&#125; SpringBoot配置Interceptor JwtInterceptor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * jwt拦截器，用token验证方式，拦截非正常登陆的token持有者 * @author GoldJack * @since 2022/7/14 */@Componentpublic class JwtInterceptor implements HandlerInterceptor &#123; @Resource private IEmployeeService employeeService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 从请求头获取token String token = request.getHeader(&quot;token&quot;); // 如果handler不一致，直接返回true if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; // 是否有token if (token == null) &#123; throw new RuntimeException(&quot;无token，请重新登陆&quot;); &#125; // 是否能从token中正确解析出employeeId Integer employeeId; try &#123; employeeId = Integer.valueOf(JWT.decode(token).getAudience().get(0));// System.out.println(employeeId); &#125; catch (JWTDecodeException j) &#123; throw new RuntimeException(&quot;token解析错误，请重新登陆&quot;); &#125; // 判断从数据库中是否能根据userId取出对应的loginUser信息 Employee employee = employeeService.getById(employeeId); if (employee == null) &#123; throw new ServiceNotFoundException(&quot;用户不存在，请重新登陆&quot;); &#125; // 密码加签验证 token JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(employee.getPassword())).build(); try &#123; jwtVerifier.verify(token); &#125; catch (JWTVerificationException e) &#123; throw new ServiceNotFoundException(&quot;token加签验证失败，请重新登陆&quot;); &#125; return true; &#125;&#125; InterceptorConfig 1234567891011121314151617@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Resource private JwtInterceptor jwtInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(jwtInterceptor) // *代表一级目录，**代表多级目录 .addPathPatterns(&quot;/**&quot;) // 拦截所有请求，通过判断token是否合法，来决定是否需要登陆 .excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;, &quot;/file/**&quot;); // 这里/file/**仅为测试文件上传功能 &#125; &#125; CORS CorsConfig CORS：Cross Origin Resource Share指跨域资源共享 12345678910111213141516171819202122@Configurationpublic class CorsConfig &#123; // 当前跨域请求最大有效时长。这里默认1天 private static final long MAX_AGE = 24 * 60 * 60; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3 设置访问源请求方法 corsConfiguration.setMaxAge(MAX_AGE); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4 对接口配置跨域设置 return new CorsFilter(source); &#125;&#125; Mybatis-plus MybatisPlusConfig 12345678910111213141516171819/** * mybatis-plus 分页插件 */@Configuration@MapperScan(&quot;com.airport.mapper&quot;)public class MybatisPlusConfig &#123; /** * 分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 以下三个依赖，都是用于mybatis-plus的代码生成器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Sql analyzer,主要用于代码生成器的数据库连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 模板引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hutool工具类，提供类似StrUtil,SecureUtil(生成uuid)等工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jwt用于token验证，配合前端的request拦截使用 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.yml12345678910111213141516171819202122server: port: 9090# 数据库连接配置spring: datasource: username: root password: admin url: jdbc:mysql://localhost:3306/airport-management?serverTimeZone=GMT%2b8&amp;useUnicode=true&amp;characterEncoding=UTF-8 driver-class-name: com.mysql.cj.jdbc.Driver# 逻辑删除配置mybatis-plus: global-config: db-config: logic-delete-value: 1 logic-not-delete-value: 0# 文件上传、存储路径files: upload: path: E:/IDEA-Workspace/airport-management/files/ 工具类工具类一般放在&#x2F;utils文件夹里 ResponseCode123456789101112131415161718192021222324252627282930313233343536373839404142/** * 响应码枚举类 * 可通过static方法引入ResponseCode，并直接使用CODE * @author GoldJack * @since 2022/7/14 */public enum ResponseCode &#123; /** * 枚举 响应码 */ CODE_200(&quot;成功OK&quot;), CODE_300(&quot;用户名或密码错误&quot;), CODE_301(&quot;用户名重复&quot;), CODE_310(&quot;更新失败&quot;), CODE_311(&quot;查询失败&quot;), CODE_312(&quot;删除失败&quot;), CODE_313(&quot;新增失败&quot;), CODE_320(&quot;权限不足&quot;), CODE_404(&quot;页面请求失败&quot;), ; private final String codeMsg; ResponseCode(String codeMsg) &#123; this.codeMsg = codeMsg; &#125; /** * 获取响应码的说明信息 * @return */ public String getCodeMessage() &#123; return codeMsg; &#125;&#125; Result123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 响应结果封装类 * @param &lt;T&gt; 需要传回前端的数据 */@Data@NoArgsConstructorpublic class Result&lt;T&gt; &#123; private ResponseCode code; private String msg; private T data; public Result(T data) &#123; this.data = data; &#125; /** * 不需要传递数据的成功响应 * @return */ public static Result success() &#123; Result result = new Result&lt;&gt;(); result.setCode(ResponseCode.CODE_200); result.setMsg(&quot;成功&quot;); return result; &#125; /** * 需要传递数据的成功响应 * @param data 传递的信息 * @return * @param &lt;T&gt; */ public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; result = new Result&lt;&gt;(data); result.setCode(ResponseCode.CODE_200); result.setMsg(&quot;成功&quot;); return result; &#125; /** * 失败响应 * @param code 失败代码 * @param msg 失败信息 * @return */ public static Result error(ResponseCode code, String msg) &#123; Result result = new Result(); result.setCode(code); result.setMsg(msg); return result; &#125;&#125; TokenUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Token工具类 * 主要用于生成token */public class TokenUtil &#123; @Resource private IEmployeeService employeeService; private static IEmployeeService staticEmployeeService; @PostConstruct public void init() &#123; staticEmployeeService = employeeService; &#125; /** * 生成token * @param userId 用户ID，此处作为载荷 * @param sign 此处用密码作为签名，实际sign中不允许包含敏感数据，因为token可以被解析 * @return */ public static String genToken(String userId, String sign) &#123; String token = JWT.create().withAudience(userId) // 将userId作为载荷 .withExpiresAt(DateUtil.offsetHour(new Date(), 2)) // 2小时后token过期 .sign(Algorithm.HMAC256(sign));// 将password作为token的密钥（实际情况不允许） return token; &#125; /** * 获取token中的用户信息，暂未实现 * @return */ public static LoginUser getCurrentUser() &#123; try &#123; HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); String token = request.getHeader(&quot;token&quot;); String aud = JWT.decode(token).getAudience().get(0); Integer userId = Integer.valueOf(aud); return LoginUser.extractEmployeeToLoginUser(staticEmployeeService.getById(userId)); &#125; catch (Exception e) &#123; System.out.println(&quot;解析token失败&quot;); return null; &#125; &#125;&#125; Controller实际的AirportManagement有LoginController，EmployeeController，PlaneController，TrackController等多个Controller，这里以LoginController 和 EmployeeController为例 LoginController123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 登陆信息 前端控制器 * @author GoldJack * @since 2022/7/14 */@RestController@RequestMappingpublic class LoginController &#123; @Autowired private IEmployeeService employeeService; @Autowired private EmployeeController employeeController; /** * 登陆 * @param loginUser LoginUser类封装了登陆相关的用户信息，后续需完善和统一功能 * @return 响应码 和 封装了信息的LoginUser */ @PostMapping(&quot;/login&quot;) public Result login(@RequestBody LoginUser loginUser) &#123; Employee selectOne = employeeService.getBaseMapper().selectOne( Wrappers.&lt;Employee&gt;lambdaQuery() .eq(Employee::getUsername, loginUser.getUsername()) .eq(Employee::getPassword, loginUser.getPassword()) );// System.out.println(&quot;selectOne = &quot; + selectOne); if (selectOne == null) &#123; return Result.error(CODE_300, CODE_300.getCodeMessage()); &#125; return Result.success(LoginUser.extractEmployeeToLoginUser(selectOne)); &#125; /** * 注册 * @param employee 接收用户前端注册时的信息并封装 * @return 响应码 */ @PostMapping(&quot;/register&quot;) public Result register(@RequestBody Employee employee) &#123; return employeeController.persistence(employee); &#125;&#125; EmployeeController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * &lt;p&gt; * 雇员信息表 前端控制器 * &lt;/p&gt; * * @author Gold_Jack * @since 2022-07-14 */@RestController@RequestMapping(&quot;/employee/management&quot;)public class EmployeeController &#123; @Autowired private IEmployeeService employeeService; /** * 持久化 * @param employee 需要持久化的Employee对象 * @return 响应码 */ @PostMapping(&quot;/persistence&quot;) public Result persistence(@RequestBody Employee employee) &#123; try &#123; Employee duplicateEmployee = employeeService.getOne( Wrappers.&lt;Employee&gt;lambdaQuery() .eq(Employee::getUsername, employee.getUsername()) ); if (duplicateEmployee != null ) &#123; // 说明用户名已经存在（不允许相同的用户名） return Result.error(CODE_301, CODE_301.getCodeMessage()); &#125; if (employee.getEmployeeName() == null) &#123; employee.setEmployeeName(employee.getUsername()); &#125; employee.setAuthority(&quot;GUEST&quot;); // 暂时在这里设置权限 employeeService.save(employee); &#125; catch (SqlSessionException sqlSessionException) &#123; return Result.error(CODE_313, CODE_313.getCodeMessage()); &#125; return Result.success(); &#125; /** * 更新 * @param employee 需要更新的Employee，由于ID没有被传入，所以需要查询数据库获取（后续要修改） * @return 响应码 */ @PutMapping(&quot;/update&quot;) public Result updateById(@RequestBody Employee employee) &#123; try &#123; employee.setEmployeeId(employeeService.getOne( Wrappers.&lt;Employee&gt;lambdaQuery() .eq(Employee::getUsername, employee.getUsername()) .eq(Employee::getPassword, employee.getPassword()) ).getEmployeeId()); employeeService.updateById(employee); &#125; catch (SqlSessionException sqlSessionException) &#123; return Result.error(CODE_310, CODE_310.getCodeMessage()); &#125; return Result.success(); &#125; /** * 按分页信息读取 * @param auth 用户权限，目前仅ADMIN可以访问用户管理界面 * @param pageNum 当前是第几页 * @param pageSize 每页的大小（记录数） * @param search 搜索内容，默认为空，返回所有数据 * @return 响应码和当前页 */ @GetMapping(&quot;/load&quot;) public Result loadByPage(@RequestParam(defaultValue = &quot;GUEST&quot;) String auth, @RequestParam(defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize, @RequestParam(defaultValue = &quot;&quot;) String search) &#123; Page&lt;Employee&gt; page; try &#123; LambdaQueryWrapper&lt;Employee&gt; wrapper = Wrappers.&lt;Employee&gt;lambdaQuery(); if (StrUtil.isNotBlank(search)) &#123; wrapper.like(Employee::getEmployeeName, search); &#125; if (Objects.equals(auth, &quot;ADMIN&quot;)) &#123; page = employeeService.page(new Page&lt;&gt;(pageNum, pageSize), wrapper); &#125; else &#123; // TODO: 非管理员仅显示自己权限内的用户 return Result.error(CODE_320, CODE_320.getCodeMessage()); &#125; &#125; catch (SqlSessionException sqlSessionException) &#123; return Result.error(CODE_311, CODE_311.getCodeMessage()); &#125; return Result.success(page); &#125; /** * 删除 * @param id 雇员ID * @return 响应码 */ @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Result deleteById(@PathVariable Long id) &#123; try &#123; employeeService.removeById(id); &#125; catch (SqlSessionException sqlSessionException) &#123; return Result.error(CODE_312, CODE_312.getCodeMessage()); &#125; return Result.success(); &#125;&#125; Mapper、Service、pojo均由mybatis-plus代码生成器自动生成，在此不再详述，可以参考下面代码生成器的配置 代码生成器一般在test目录下编写单独的类存放，配置好后，作为test运行。详细说明，请看Mybatis-Plus.md。 CodeGenerator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 代码生成器 */@SpringBootTestpublic class CodeGenerator &#123; private static final DataSourceConfig DATA_SOURCE_CONFIG = new DataSourceConfig // 配置数据源 .Builder(&quot;jdbc:p6spy:mysql://localhost:3306/airport-management?serverTimeZone=GMT%2b8&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;admin&quot;) .schema(&quot;airport-management&quot;) .build(); private static final String PROJECT_PATH = System.getProperty(&quot;user.dir&quot;); // 获取项目路径 private static final GlobalConfig GLOBAL_CONFIG = new GlobalConfig.Builder() // 全局配置 .outputDir(PROJECT_PATH + &quot;/src/main/java&quot;) // 代码生成路径 .author(&quot;Gold_Jack&quot;) .disableOpenDir() // 生成后不打开explorer窗口 .dateType(DateType.ONLY_DATE).build(); // !!! 最终项目路径 // 代码生成路径/父目录名称/包名称 // - pojo // - Entity.java // - service // - controller // - mapper // - EntityMapper.java (extends BaseMapper&lt;&gt;) private static final PackageConfig PACKAGE_CONFIG = new PackageConfig.Builder() // 配置包文件 // 由于项目创建时没有创建包，所以不需要写.moduleName(&quot;MODULE_NAME&quot;) .parent(&quot;com.airport&quot;) // 父目录名称 .entity(&quot;pojo&quot;) // 实体类文件夹名称... .mapper(&quot;mapper&quot;) .service(&quot;service&quot;) .controller(&quot;controller&quot;).build(); private static final StrategyConfig STRATEGY_CONFIG = new StrategyConfig.Builder() // 策略配置 // 数据库表名称, 可以多个同时生成 .addInclude(&quot;file&quot;) .entityBuilder() // 通过entityBuilder()，可以开启TableFill，Lombok，NamingStrategy等 .enableLombok() .columnNaming(NamingStrategy.underline_to_camel) .naming(NamingStrategy.underline_to_camel).build(); @Test void generateCode() &#123; AutoGenerator generator = new AutoGenerator(DATA_SOURCE_CONFIG); generator.global(GLOBAL_CONFIG) .strategy(STRATEGY_CONFIG) .packageInfo(PACKAGE_CONFIG); // 自动生成器配置，依次传入四个配置文件 generator.execute(); &#125;&#125; Ngork部署国内官网：https://www.ngrok.cc/user.html 下载客户端后，解压文件夹，用cmd工具cd到文件夹目录 12345678910111213141516171819202122&gt;&gt; cd &lt;NGORK_DIR&gt;&gt;&gt; sunny.exe cliendid &lt;隧道ID&gt; # 隧道ID在官网的隧道管理界面获取Sunny-Ngrok www.ngrok.cc (Ctrl+C to quit)Tunnel Status online # 出现online说明链接成功Version 2.1.1/2.1.1Forwarding http://airportmanagementjack.vipgz1.91tunnel.com -&gt; localhost:9000Web Interface 127.0.0.1:4040# Conn 32Avg Conn Time 2324.03ms HTTP Requests-------------GET /universal-prefix/employeGET /js/src_views_management_ 200 OKGET /universal-prefix/plane/mGET /js/src_views_management_ 200 OKGET /universal-prefix/home 200 OKPOST /universal-prefix/login 200 OK POST /universal-prefix/registe 200 OK GET /js/src_views_login-view_ 200 OK GET /js/src_views_login-view_ 200 OK 回隧道管理界面，用赠送域名，即可访问 注意：域名通过聊天软件发送可能会被屏蔽，可以放在txt文件中发送 Header问题Ngork部署时，会报Invalid Header错误，需要在vue.config.js中做如下配置 1234567module.exports = defineConfig(&#123; devServer: &#123; // ... historyApiFallback: true, allowedHosts: &quot;all&quot;, // 允许所有Hosts访问 &#125;&#125;) TODO 用户头像上传、更新 文件管理系统 继承spring security实现角色、权限功能 在主页嵌入echarts 解决飞机管理中的日期，前后端、数据库传递中的类型转换问题 用户访问时，重定向会引发一次token验证错误，需重新规划路由解决","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]},{"title":"Docker","slug":"notes/Docker","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:44:44.103Z","comments":true,"path":"2022/09/28/notes/Docker/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Docker/","excerpt":"","text":"Docker BasicsDocker Installation on Ubuntu​ see Docs on https://docs.docker.com/ How to start Docker service12jack123@Jack:~$ sudo service docker start * Starting Docker: docker [ OK ] Basic CommandsGraph Docker Images1234567docker images # show all images in this environmentdocker search &lt;IMAGE_NAME&gt; # search specific image in DockerHub(https://hub.docker.com/)docker pull &lt;IMAGE_NAME&gt;:&lt;IMAGE_VERSION&gt; # download image from DockerHubdocker run -it &lt;IMAGE_NAME&gt; /bin/bash # -it: run with interactions # -d: run in backstage # --name: specify container namedocker rmi &lt;IMAGE_NAME&gt; # delete image Docker Containers1234567891011docker ps # show all containers that are runningdocker ps -a # show all containersdocker rm &lt;CONTAINER_ID&gt; / docker rm &lt;CONTAINER_NAME&gt; # remove specific containerdocker stop &lt;CONTAINER_ID&gt; / .. # stop this containerdocker rm -f $(docker ps -aq) # remove all containers#use exit in running container can exit and stop the containerroot@1de6ff9112df:/usr/local/tomcat# exit # use ctrl+P+Q can exit the container but avoid stopping it^P^Q Docker VolumesUsually, or in currenty study, we use volumes in two situations. One is running a docker image and the other is compiling a Dockerfile. run parameter(-v, –volume) 12345671. docker run -v &lt;HOST_DIR&gt;:&lt;IMAGE_DIR&gt; # e.g.Mount MySql config: # docker run -it -v /etc/docker/conf:/usr/docker/conf.v mysql_01 mysql:5.72. docker run -v &lt;VOLUME_NAME&gt;3. docker run -v &lt;VOLUME_NAME&gt;:&lt;IMAGE_DIR&gt; Dockerfile(VOLUME) 123FROM centos:7VOLUME [&quot;volume1&quot;, &quot;volume2&quot;] # create two volumes in this image Docker History1234567891011121314jack123@Jack:~$ docker history my_centos:0.1IMAGE CREATED CREATED BY SIZE COMMENT0c1cc2bcc347 16 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin… 0B9103bfeb16e1 16 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B9be46ddfa2fe 16 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B7fc193ca45f9 16 minutes ago /bin/sh -c #(nop) EXPOSE 80 0Bd3955d272346 16 minutes ago /bin/sh -c yum -y install net-tools 171MBd03960a030ca 16 minutes ago /bin/sh -c yum -y install vim 226MBecc88ed86c61 16 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B80b3acfc39dd 16 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0Bf8b5cf8ee32e 16 minutes ago /bin/sh -c #(nop) MAINTAINER Gold_Jack&lt;gold… 0Beeb6ee3f44bd 8 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B&lt;missing&gt; 8 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B&lt;missing&gt; 8 months ago /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4… 204MB Docker Inspect12# we can see detailed info by &quot;docker inspect &lt;CONTAINER_ID&gt;&quot;jack123@Jack:~$ docker inspect aeb265c66a3f Dockerfile123# All commands in Dockerfile must be capitalFROM basic image # offical centos is built from scratchMAINTAINER: owner&lt;@email&gt; ENTRYPOINT and CMDENTRYPOINT and CMD both run commands in Dockerfile. However, when we build an image through this Dockerfile and run it with some additional parameters, differences between ENTRYPOINT and CMD will occur. 1234567891011121314151617181920jack123@Jack:~$ docker build -f Dockerfile -t test .# use CMDDockerfile_CMD:FROM centos:7CMD [&quot;ls&quot;, &quot;-a&quot;]jack123@Jack:~$ docker run test # will list all files and directoriesjack123@Jack:~$ docker run test -l # ERROR!# -l will replace [&quot;ls&quot;, &quot;-a&quot;] in Dockerfile_CMD#use ENTRYPOINTDockerfile_ENTRYPOINT:FROM centos:7ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;]jack123@Jack:~$ docker run test # same as abovejack123@Jack:~$ docker run test -l # list all# ENTRYPOINT will attach additional parameters after &quot;docker run&quot; to ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;]# it turns out to be ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;] How to build my own image by Dockerfile1. write Dockerfile1jack123@Jack:~$ cat dockerfile_myCentos 1234567891011121314FROM centos:7 # ATTENTION: centos8 is no longer been maintained. Use centos7 instead.MAINTAINER Gold_Jack&lt;gold_jack@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash 2. build myCentos image12345jack123@Jack:~$ docker build -f dockerfile_myCentos -t my_centos:0.1 .jack123@Jack:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmy_centos 0.1 0c1cc2bcc347 3 minutes ago 601MB # my Centos here!centos 7 eeb6ee3f44bd 8 months ago 204MBtest 3. test image12345678910111213141516171819202122232425262728jack123@Jack:~$ docker run -it --name mycentos my_centos:0.1 /bin/bash[root@03b1aa80c24f local]## 1. test vim[root@03b1aa80c24f local]# cd src[root@03b1aa80c24f src]# ls[root@03b1aa80c24f src]# vim a.c[root@03b1aa80c24f src]# cat a.chello myCentos# 2. test ifconfig[root@03b1aa80c24f src]# clear[root@03b1aa80c24f src]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 12 bytes 976 (976.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Practice: Make TOMCAT Image1.Dockerfile1jack123@Jack:/tmp/tomcat$ cat Dockerfile 12345678910111213141516171819202122232425262728FROM centos:7MAINTAINER jack&lt;gold_jack@163.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.63.tar.gz /usr/local/ADD jdk-8u221-linux-x64.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/local/WORKDIR $MYPATH# jdk &lt;DIR_NAME&gt; must corresponding to the dir name in image.# so build image first and then enter into container to see what the dir name is.# then stop and remove container, remove image# edit the Dockerfile and re-build image# for example, I use jdk8, and the &lt;DIR_NAME&gt; is jdk1.8.0_221 in the containerENV JAVA_HOME /usr/local/jdk1.8.0_221 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.63ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.63ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$CATALINA_HOME/libEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.63/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.63/bin/logs/catalin 2.build Image12345jack123@Jack:/tmp/tomcat$ docker build -t mytomcat .# if &#x27;no permission to read from &#x27;/tmp/tomcat/logs/catalina.out&#x27;&#x27;.# use sudojack123@Jack:/tmp/tomcat$ sudo docker build -t mytomcat . 3.Run Iamge12345678910jack123@Jack:/tmp/tomcat$ docker run -d --name mytomcat01 \\&gt; -p 9000:8080 \\&gt; -v /tmp/tomcat/test/:/usr/local/apache-tomcat-9.0.63/webapps/test \\&gt; -v /tmp/tomcat/logs/:/usr/local/apache-tomcat-9.0.63/logs \\&gt; mytomcat4106f28af916151471cc535ac2b06fea24b6b36eeb9e21ed09ffeee56c5f29bajack123@Jack:/tmp/tomcat$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4106f28af916 mytomcat &quot;/bin/sh -c &#x27;/usr/lo…&quot; 1 second ago Up 1 second 0.0.0.0:9000-&gt;8080/tcp, :::9000-&gt;8080/tcp mytomcat01 4.Test Connection12345jack123@Jack:/tmp/tomcat$ curl localhost:9000 -I # -I, --head Show document info onlyHTTP/1.1 200Content-Type: text/html;charset=UTF-8Transfer-Encoding: chunkedDate: Thu, 09 Jun 2022 04:18:46 GMT 5.Create WEB_INF&#x2F;web.xml12# web.xml&#x27;s content is fixedjack123@Jack:/tmp/tomcat/test/WEB_INF$ cat web.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/web-app&gt; 6.Create index.jsp1234567891011jack123@Jack:/tmp/tomcat/test$ sudo vim index.jspjack123@Jack:/tmp/tomcat/test$ cat index.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;% System.out.println(&quot;\\nWe have successfully opened this tomcat server.&quot;);%&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 7.Test localhost:9090&#x2F;test1curl localhost:9090/test ---&gt; success return &quot;Hello World&quot; 8.Check logs123456789101112131415161718192021jack123@Jack:/tmp/tomcat/logs$ sudo cat catalina.out//......//We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server.We have successfully opened this tomcat server. 9.Push MyTomcat to DockerHub1234567891011121314151617181920212223242526# login to DockerHubjack123@Jack:/tmp/tomcat/logs$ docker login -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt;# change tag and repository namejack123@Jack:/tmp/tomcat/logs$ docker tag mytomcat goldjack/tomcat:1.0jack123@Jack:/tmp/tomcat/logs$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgoldjack/tomcat 1.0 18069f342233 59 minutes ago 853MBmytomcat latest 18069f342233 59 minutes ago 853MBmy_centos 0.1 0c1cc2bcc347 24 hours ago 601MBcentos 7 eeb6ee3f44bd 8 months ago 204MB# push my image to DockerHub# iamge is commited in layers!jack123@Jack:/tmp/tomcat/logs$ docker push goldjack/tomcat:1.0The push refers to repository [docker.io/goldjack/tomcat]2295ae19f1d2: Pushed6510d41890d9: Pushedf1447c90adfb: Pushed97f68fd24610: Pushed174f56854903: Mounted from library/centos1.0: digest: sha256:393dec84d04d28b905011d1b020ef90dbea3d4c35842fff7a1726f983dbb4df6 size: 1373# log outjack123@Jack:/tmp/tomcat/logs$ docker logoutRemoving login credentials for https://index.docker.io/v1/ Docker NetworkPRE: remove all images and containers. How does docker handle container network access?123456789101112131415161718192021222324252627282930313233# run tomcat# -P, --publish-all Publish all exposed ports to random portsjack123@Jack:/tmp/tomcat/logs$ docker run -d -P --name tomcat01 tomcat# IP infojack123@Jack:/tmp/tomcat/logs$ docker exec -it tomcat01 /bin/bashroot@1de6ff9112df:/usr/local/tomcat# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.03: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.028: eth0@if29: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # ping IP: Successjack123@Jack:/$ ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.056 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.091 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.093 ms64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.092 ms64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.086 ms64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.093 ms^C--- 172.17.0.2 ping statistics ---6 packets transmitted, 6 received, 0% packet loss, time 5225msrtt min/avg/max/mdev = 0.056/0.085/0.093/0.013 ms Veth-pairVeth-pair is a virtual device interface that shows in pairs. It connects to Network Stack in one direction and connects to its partners in the other. It is often used in Linux Bridge. Communication Process In the diagram above, the Main Router, also referred to as Docker0, holds one IP(172.17.0.1). Other images such as Tomcat01 and Tomcat02 will be allocated two numbers, usually continuous, as their communication interface to the Main Router. When Tomcat01 sends a request to Tomcat02, it is not the direct communication between two containers but through the Main Router(Docker0). Tomcat01 sends a request to Docker0 through port 261. Docker0 receives the request from port 262 because veth@if261 is true. Docker0 will store the IP of Tomcat01 if it was not in the Routing Table. (When Docker service initialized, its routing table only possesses the IP of itself, usually 172.17.0.1. Only when the Main Router receives a request from a new IP, it will consequently update its routing table.) Docker0 broadcasts the request through all ports. Tomcat02 receives the request from port 263 because eth0@if264 is true and the request’s target address is 172.17.0.3. Conclusion: All Docker containers run in local area network(LAN), so they can communicate with each other through the Main Router(Docker0). Ping Test123456789101112131415161718192021222324252627# run two containers: tomcat01 and tomcat02jack123@Jack:~$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES63d426e83ddb tomcat &quot;catalina.sh run&quot; 8 minutes ago Up 8 minutes 0.0.0.0:49154-&gt;8080/tcp, :::49154-&gt;8080/tcp tomcat021de6ff9112df tomcat &quot;catalina.sh run&quot; 2 hours ago Up 2 hours 0.0.0.0:49153-&gt;8080/tcp, :::49153-&gt;8080/tcp tomcat01# use ip addr to check each containers&#x27; IP addresstomcat01: 172.17.0.2tomcat02: 172.17.0.3# Before Ping, we should install dependencies and utilsapt updateapt-get updateapt install -y iproute2 # to make &quot;ip a&quot; Runnalbeapt-get install inetutils-ping # to make &quot;ping&quot; Runnable# ping tomcat02 in tomcat01: Successroot@1de6ff9112df:/usr/local/tomcat# ping 172.17.0.3PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: icmp_seq=0 ttl=64 time=0.077 ms64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.126 ms64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.135 ms64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.121 ms64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.109 ms^C--- 172.17.0.3 ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.077/0.114/0.135/0.000 ms –link12345678910111213141516171819202122232425262728# use --link can connect one container to another without knowing concrete IP# firstly, we have to ensure that the anchored container(tomcat01) is runningdocker: Error response from daemon: Cannot link to a non running container: /tomcat01 AS /tomcat02/tomcat01.jack123@Jack:~$ docker start tomcat01tomcat01# Then, we can run tomcat02 can connect it to tomcat01jack123@Jack:~$ docker run -d -P --name tomcat02 --link tomcat01 tomcat88ee3d6a91cb4449138f371508b273ae3b9faa98a564b4430fbb3a3e5f63d2bb# Ping testjack123@Jack:~$ docker exec -it tomcat02 ping tomcat01PING tomcat01 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.058 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.201 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.160 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.215 ms64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.230 ms64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.264 ms64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.204 ms^C--- tomcat01 ping statistics ---7 packets transmitted, 7 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.058/0.190/0.264/0.061 ms# BUT!!! reverse ping is deniedjack123@Jack:~$ docker exec -it tomcat01 ping tomcat02ping: unknown host Network Inspect1234567jack123@Jack:~$ docker network lsNETWORK ID NAME DRIVER SCOPE5c25881d40ff bridge bridge local # Docker03d27af74540a host host local68bf3a526a05 none null localjack123@Jack:~$ docker network inspect 5c25881d40ff HostsThe operation of –link is fundamentally add a “ “ pair into hosts. For now, it is “172.17.0.2 tomcat01 “ 12345678910jack123@Jack:~$ docker exec -it tomcat02 /bin/bashroot@88ee3d6a91cb:/etc# cat hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 tomcat01 1de6ff9112df # in tomcat02:/etc/hosts, we can see tomcat02 bound to tomcat 01172.17.0.3 88ee3d6a91cb Create My Network12345# when we use commands below to run a imagedocker run -d -P tomcat01 tomcat# it hides a default parameter --net bridge, which equalsdocker run -d -P tomcat01 --net bridge tomcat# and bridge here means Docker0 Customize My Network12345# --driver bridge: use bridge to connect# --subnet 192.168.0.0/16: sub networks range from 192.168.0.2~192.168.255.255# --gateway 192.168.0.1jack123@Jack:~$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet860a478371a3444a665ec9f2fe41e61a1dffc1b6d67a280f5b3d41d78947eca9 Inspect Mynet12345678910111213141516171819202122232425262728293031323334353637jack123@Jack:~$ docker network lsNETWORK ID NAME DRIVER SCOPE5c25881d40ff bridge bridge local3d27af74540a host host local860a478371a3 mynet bridge local # mynet68bf3a526a05 none null localjack123@Jack:~$ docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;860a478371a3444a665ec9f2fe41e61a1dffc1b6d67a280f5b3d41d78947eca9&quot;, &quot;Created&quot;: &quot;2022-06-10T12:20:58.52555606+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, # --driver &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, # --subnet &quot;Gateway&quot;: &quot;192.168.0.1&quot; # --gateway &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;] Create Two Tomcats Running in Mynet1234jack123@Jack:~$ docker run -d -P --name tomcat-net-01 --net mynet tomcat84fcf554af5184e62418349a8bb63ad61e7f9190a459990111a7b5aec634ee96jack123@Jack:~$ docker run -d -P --name tomcat-net-02 --net mynet tomcat7e63e7edb8c6fe26e98a7b187b598b248e8dbcf0df03526a342af11faf7d82ed Again: Inspect Mynet12345678910111213141516171819202122232425262728293031323334353637383940414243444546jack123@Jack:~$ docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;860a478371a3444a665ec9f2fe41e61a1dffc1b6d67a280f5b3d41d78947eca9&quot;, &quot;Created&quot;: &quot;2022-06-10T12:20:58.52555606+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;7e63e7edb8c6fe26e98a7b187b598b248e8dbcf0df03526a342af11faf7d82ed&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;EndpointID&quot;: &quot;4a34bcb2e451ccddd7496b0766a2c24e45bd7c739a10f9ae053afe241e689ecf&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;84fcf554af5184e62418349a8bb63ad61e7f9190a459990111a7b5aec634ee96&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;EndpointID&quot;: &quot;314e2043f15e9420ba48a81c7b2e5ce7a57af0d5e65a670b32d16350cc2a2fb1&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;] we can see two Tomcat servers running in mynet which were allocated IP 192.168.0.2 and 192.168.0.1. Ping Test Between Tomcat-net-01 and Tomcat-net-02123456789101112131415161718192021# ping IPjack123@Jack:~$ docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3): 56 data bytes64 bytes from 192.168.0.3: icmp_seq=0 ttl=64 time=0.065 ms64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.125 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.098 ms64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.121 ms^C--- 192.168.0.3 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.065/0.102/0.125/0.024 ms# ping container namejack123@Jack:~$ docker exec -it tomcat-net-02 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2): 56 data bytes64 bytes from 192.168.0.2: icmp_seq=0 ttl=64 time=0.037 ms64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.130 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.152 ms64 bytes from 192.168.0.2: icmp_seq=3 ttl=64 time=0.159 ms^C--- tomcat-net-01 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.037/0.119/0.159/0.049 ms SummaryCustomized network can avoid the flaws of Docker0. If we are to deploy docker swarms like redis and mysql, we can create two networks such as redis-net and mysql-net. Because two networks are isolated, the redis server and the mysql server have no mutual interference. New Container to Mynet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# create new tomcat01jack123@Jack:~$ docker run -d -P --name tomcat01 tomcatd58690b58cf9085c6bac8240c317c873f6c4072453dcd28290ae63c4e09d0e27# docker network connect INFOjack123@Jack:~$ docker network connect --helpUsage: docker network connect [OPTIONS] NETWORK CONTAINER# connect tomcat01 to mynetjack123@Jack:~$ docker network connect mynet tomcat01 # run successfullyjack123@Jack:~$ docker inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;860a478371a3444a665ec9f2fe41e61a1dffc1b6d67a280f5b3d41d78947eca9&quot;, &quot;Created&quot;: &quot;2022-06-10T12:20:58.52555606+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;7e63e7edb8c6fe26e98a7b187b598b248e8dbcf0df03526a342af11faf7d82ed&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;EndpointID&quot;: &quot;4a34bcb2e451ccddd7496b0766a2c24e45bd7c739a10f9ae053afe241e689ecf&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;84fcf554af5184e62418349a8bb63ad61e7f9190a459990111a7b5aec634ee96&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;EndpointID&quot;: &quot;314e2043f15e9420ba48a81c7b2e5ce7a57af0d5e65a670b32d16350cc2a2fb1&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;d58690b58cf9085c6bac8240c317c873f6c4072453dcd28290ae63c4e09d0e27&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, # new tomcat01 was connected to mynet &quot;EndpointID&quot;: &quot;363e4fac8b35b7b85ba220c5b461111ec96b03ec505af3184d33e9dd356d8072&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;, # allocated IP &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# ping test between new tomcat01 and two old tomcatsjack123@Jack:~$ docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2): 56 data bytes64 bytes from 192.168.0.2: icmp_seq=0 ttl=64 time=0.061 ms64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.132 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.119 ms^C--- tomcat-net-01 ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.061/0.104/0.132/0.031 ms Two IP One ContainerFor tomcat01, it has IP:172.17.0.2 in Docker0. Meanwhile, because it has been connected to mynet, it also possesses IP:192.168.0.4 in mynet. This is the situation that one container has two IPs. Similar to private net IP and public net IP in real router. Docker-composeIntroductionCompose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see the list of features. Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in Common Use Cases. Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary. Intallation Download Docker-compose 1sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose Authorize 1sudo chmod +x /usr/local/bin/docker-compose Check docker-compose version 123456docker-compose --versiondocker-compose version 1.17.0, build ac53b73docker-py version: 2.5.1CPython version: 2.7.13OpenSSL version: OpenSSL 1.0.1t 3 May 2016","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"middleware","slug":"middleware","permalink":"https://gold-jack.github.io/tags/middleware/"}]},{"title":"Linux","slug":"notes/Linux","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:45:17.298Z","comments":true,"path":"2022/09/28/notes/Linux/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Linux/","excerpt":"","text":"LinuxApt-get Config Configuration to accelerate downloading process 123456789101112131415161718192021222324#进入容器docker exec -it &lt;容器名称/id&gt; bash#执行命令apt-get 发现缓慢apt-get update #执行命令 Ctrl + C 停止 返回命令行cd /ect/apt#查看目录lsroot@62be94cc90e7:/etc/apt# lsapt.conf.d auth.conf.d preferences.d sources.list sources.list.d trusted.gpg.d#执行备份命令 --避免修改失败无法使用，备份可恢复cp sources.list sources.list.bak#执行命令 更改apt-get 不用安装vim (vim真的太慢了)echo &quot;&quot;&gt;sources.listecho &quot;deb http://ftp2.cn.debian.org/debian/ buster main&quot;&gt;&gt;sources.listecho &quot;deb http://ftp2.cn.debian.org/debian/debian-security buster/updates main&quot;&gt;&gt;sources.listecho &quot;deb http://ftp2.cn.debian.org/debian/debian buster-updates main&quot;&gt;&gt;sources.list#更改完成后执行命令apt-get update #将备份完成的文件改回来，即可。#rm --删除文件后使用 mv --更改文件名字rm sources.listmv sources.list.bak sources.list TODO learn linux commands thoroughly read source code","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://gold-jack.github.io/tags/linux/"}]},{"title":"Mybatis-Plus","slug":"notes/Mybatis-Plus","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:45:53.127Z","comments":true,"path":"2022/09/28/notes/Mybatis-Plus/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Mybatis-Plus/","excerpt":"","text":"Mybatis-Plus官方文档快速开始: https://baomidou.com/pages/24112f/配置config.java config.MyBatisPlusConfig 123456789101112131415@MapperScan(&quot;com.example.mybatisplus.mapper&quot;) // 开启包扫描@EnableTransactionManagement@Configurationpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); // 分页插件 return interceptor; &#125;&#125; application.yml1234567891011121314151617spring: # 连接mysql datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: admin # user_db: 数据库名称 # serverTimeZone: mysql8.0必须配置 url: jdbc:mysql://localhost:3306/user_db?serverTimeZone=Asia/Shanghai&amp;useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8mybatis-plus: # mybatis-plus配置 global-config: db-config: # 配置逻辑删除# logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) configuration: # 配置mybatis-plus日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;dependencies&gt; &lt;!-- Mysql database &amp; driver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- google Gson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis-plus basics and generator--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Tomcat server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Sql analyzer --&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 模板引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类pojo.User1234567891011121314151617181920212223242526272829303132333435363738394041@Data // lombok注解模式 提供对应的get/set/toString方法@AllArgsConstructor // 全参数构造方法@NoArgsConstructor // 无参数构造方法@TableName(&quot;t_user&quot;) // 表名称public class User &#123; // 表中所有属性在此罗列 // @TableId注解是专门⽤在主键上的注解， // 据库中的主键字段名和实体中的属性名不⼀样,且不是驼峰之类的对应关系，可以在实体中表⽰主键的属性上加@Tableid注解， // 并指定@Tableid注解的value属性值为表中主键的字段名既可以对应上 /* （@TableId.class） @Documented @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;) public @interface TableId &#123; String value() default &quot;&quot;; IdType type() default IdType.NONE; // ! &#125; */ @TableId(type = IdType.AUTO) // IdType见下方 private String userid; private String username; private String userstatus; @Version // 版本控制，配合乐观锁（OptimisticLockerIntercepter） private Integer version; // 自动填充 // gmt_create代表记录被创建的时间 // 故采用FieldFill.INSERT，代表仅在插入时更新字段 @TableField(fill = FieldFill.INSERT) private LocalDateTime gmt_create; // gmt_update代表记录被更新的时间 // 故采用FieldFill.INSRET_UPDATE，代表在插入和更新时都需修改此字段 @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime gmt_update;&#125; IdType1234567891011121314151617public enum IdType &#123; AUTO(0), // 自增，前提是数据库的主键是自增的 NONE(1), // （默认）雪花算法 INPUT(2), ASSIGN_ID(3), ASSIGN_UUID(4); private final int key; private IdType(int key) &#123; this.key = key; &#125; public int getKey() &#123; return this.key; &#125;&#125; 雪花算法相关博客：https://blog.csdn.net/jiaomubai/article/details/124385324 自动填充 handler.MyMetaObjectHandler 具体书写模式可以参照baomidou官网的mybatis-plus文档 123456789101112131415161718@Slf4j // 开启日志@Component // 注入bean!!!public class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;Start Insert Fill...&quot;); this.strictInsertFill(metaObject, &quot;gmt_create&quot;, LocalDateTime::now, LocalDateTime.class); this.strictInsertFill(metaObject, &quot;gmt_update&quot;, LocalDateTime::now, LocalDateTime.class); &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;Start Update Fill...&quot;); this.strictUpdateFill(metaObject, &quot;gmt_update&quot;, LocalDateTime::now, LocalDateTime.class); &#125;&#125; Mapper类 mapper.UserMapper(Interface) 1234@Repository// 此处仅需让自己的xxxMapper继承BaseMapper&lt;xxx&gt;，即可获得增删改查操作public interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; (BaseMapper) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; int insert(T entity); int deleteById(Serializable id); int deleteById(T entity); int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap); int delete(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); int deleteBatchIds(@Param(&quot;coll&quot;) Collection&lt;?&gt; idList); int updateById(@Param(&quot;et&quot;) T entity); int update(@Param(&quot;et&quot;) T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper); T selectById(Serializable id); List&lt;T&gt; selectBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList); List&lt;T&gt; selectByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap); default T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper) &#123; List&lt;T&gt; ts = this.selectList(queryWrapper); if (CollectionUtils.isNotEmpty(ts)) &#123; if (ts.size() != 1) &#123; throw ExceptionUtils.mpe(&quot;One record is expected, but the query result is multiple records&quot;, new Object[0]); &#125; else &#123; return ts.get(0); &#125; &#125; else &#123; return null; &#125; &#125; default boolean exists(Wrapper&lt;T&gt; queryWrapper) &#123; Long count = this.selectCount(queryWrapper); return null != count &amp;&amp; count &gt; 0L; &#125; Long selectCount(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;T&gt; selectList(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;Object&gt; selectObjs(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); &lt;P extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; P selectMapsPage(P page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);&#125; Controller类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SuppressWarnings(&quot;all&quot;) // 忽略所有警告@RestController // 注入bean，申明为Controllerpublic class UserController &#123; @Autowired(required = false) private UserMapper userMapper; @Autowired(required = false) private Gson gson; // Gson是谷歌的插件，gson可以把Object和json格式相互转换，但存在问题！！！ @GetMapping(&quot;/insert&quot;) // 设置访问路径，此处为 localhost:[port]/insert public int insert() &#123; User user = new User(); user.setUserid(&quot;030&quot;); user.setUsername(&quot;ycy&quot;); user.setUserstatus(&quot;In&quot;); int insertResult = userMapper.insert(user); return insertResult; &#125; @GetMapping(&quot;/all&quot;) public String selectAll() &#123; List&lt;User&gt; userList = userMapper.selectList(null);// return userList; return gson.toJson(userList); // 此处与gmt_create,gmt_update的LocalDateTime类型冲突，未解决！！！ &#125; @GetMapping(&quot;/update&quot;) public int update() &#123; User user = new User(); user.setUserid(&quot;030&quot;); user.setUsername(&quot;ycy&quot;); user.setUserstatus(&quot;Out&quot;); int updateResult = userMapper.updateById(user); return updateResult; &#125; public void updateOne(User user) &#123; userMapper.updateById(user); &#125; @GetMapping(&quot;/select&quot;) public User selectOne(String userid) &#123; User user = userMapper.selectById(userid); return user; &#125; @GetMapping(&quot;/!!forceupdate&quot;) public void __forceUpdateAll__() throws Exception &#123; List&lt;User&gt; userList = userMapper.selectList(null); userList.stream().forEach(user -&gt; &#123; System.out.println(user); userMapper.updateById(user); &#125;); &#125;&#125; 逻辑删除 物理删除：从数据库中直接删除逻辑删除：记录在数据库中没有被移除，而是通过一个变量来让他生效deleted&#x3D;0：未被删除deleted&#x3D;1：已被删除 管理员可以查看被删除的数据，防止数据的丢失，类似于回收站。 在数据库中增加deleted字段，默认值为0； 在实体类中增加属性 12@TableLogicprivate Integer deleted; 配置逻辑删除组件(新版不需要，存疑？) 1234@Beanpublic ISqlInjector sqlInjector() &#123; return new LogicSqlInjector();&#125; YAML配置 123456mybatis-plus: global-config: db-config:# logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) Wrapper 普通查询 123456789@Testvoid wrapperTest() &#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.between(&quot;userid&quot;, &quot;010&quot;, &quot;019&quot;) .eq(&quot;userstatus&quot;, &quot;off&quot;) .isNotNull(&quot;username&quot;); List&lt;User&gt; userList = userMapper.selectList(userQueryWrapper); userList.forEach(System.out::println);&#125; 1234567891011Consume Time：6 ms 2022-06-25 12:30:51 # p6spy日志输出sql分析结果 Execute SQL： SELECT userid,username,userstatus,version,gmt_create,gmt_update,deleted FROM t_user WHERE deleted=0 AND (userid BETWEEN &#x27;010&#x27; AND &#x27;019&#x27; AND userstatus = &#x27;off&#x27; AND username IS NOT NULL) 子查询 12345678@Testvoid wrapperSubQueryTest() &#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.inSql(&quot;userid&quot;, &quot;select userid from t_user where userid between &#x27;010&#x27; and &#x27;019&#x27;&quot;); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println);&#125; 1234567891011Consume Time：6 ms 2022-06-25 12:42:20 Execute SQL：SELECT userid,username,userstatus,version,gmt_create,gmt_update,deleted FROM t_user WHERE deleted=0 AND (userid IN (select userid from t_user where userid between &#x27;010&#x27; and &#x27;019&#x27;))&lt;== Columns: userid, username, userstatus, version, gmt_create, gmt_update, deleted&lt;== Row: 010, 郑明杰, UNKNOWN, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Row: 012, 赵子涵, off, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Row: 013, 李琳, off, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Row: 014, 方珊珊, UNKNOWN, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Row: 015, 王杰, off, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Row: 016, 夏天辰, on, 5, 2022-06-22 15:00:41, 2022-06-25 11:37:46, 0&lt;== Total: 6 代码自动生成器MysqlGeneratorTest MysqlGeneratorTest.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@SpringBootTest // 申明springboot测试类// @RunWith(SpringRunner.class) // 开启junit日志public class MysqlGeneratorTest &#123; private static final DataSourceConfig DATA_SOURCE_CONFIG = new DataSourceConfig // 配置数据源 .Builder(&quot;jdbc:p6spy:mysql://localhost:3306/acldb?serverTimeZone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;admin&quot;) .schema(&quot;acldb&quot;) .build(); private static final String PROJECT_PATH = System.getProperty(&quot;user.dir&quot;); // 获取项目路径 private static final GlobalConfig GLOBAL_CONFIG = new GlobalConfig.Builder() // 全局配置 .outputDir(PROJECT_PATH + &quot;/src/main/java&quot;) // 代码生成路径 .author(&quot;Gold_Jack&quot;) .disableOpenDir() // 生成后不打开explorer窗口 .dateType(DateType.ONLY_DATE).build(); private static final PackageConfig PACKAGE_CONFIG = new PackageConfig.Builder() // 配置包文件 .moduleName(&quot;security&quot;) // 包名称 .parent(&quot;com.example&quot;) // 父目录名称 .entity(&quot;pojo&quot;) // 实体类文件夹名称... .mapper(&quot;mapper&quot;) .service(&quot;service&quot;) .controller(&quot;controller&quot;) .enableSwagger().build(); // 开启swagger2组件, // 在pom中需配置springfox-swagger2和springfox-swagger-ui private static final StrategyConfig STRATEGY_CONFIG = new StrategyConfig.Builder() // 策略配置 // 数据库表名称, 可以多个同时生成 .addInclude(&quot;acl_permission&quot;, &quot;acl_role&quot;, &quot;acl_role_permission&quot;, &quot;acl_user&quot;, &quot;acl_user_role&quot;) .entityBuilder() // 通过entityBuilder()，可以开启TableFill，Lombok，NamingStrategy等 .enableLombok() .columnNaming(NamingStrategy.underline_to_camel) .naming(NamingStrategy.underline_to_camel).build(); // !!! 最终项目路径 // 代码生成路径/父目录名称/包名称 // - pojo // - Entity.java // - service // - controller // - mapper // - EntityMapper.java (extends BaseMapper&lt;&gt;) @Test public void testSimple() &#123; AutoGenerator generator = new AutoGenerator(DATA_SOURCE_CONFIG); generator.global(GLOBAL_CONFIG) .strategy(STRATEGY_CONFIG) .packageInfo(PACKAGE_CONFIG); // 自动生成器配置，依次传入四个配置文件 generator.execute(); &#125;&#125; 生成结果","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]},{"title":"Nginx","slug":"notes/Nginx","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:46:07.923Z","comments":true,"path":"2022/09/28/notes/Nginx/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Nginx/","excerpt":"","text":"NginxSource Code Download​ https://github.com/nginx/nginx.git IntroductionWhat is Reverse Proxy Reverse proxy means deploying a server between database-side router and databases. Suppose that Redis_1’s IP is 172.17.0.2, Redis_2 is 172.17.0.3 and so on, clients access the website using an universal URL, like http://org.jacksNgnix.com. The reverse proxy server’s duty is to store and forward these requests to different databases or servers. As for the graph above, the reverse proxy server collect requests from the nearest router and then forward them to Redis_1, Redis_2 or Redis_N. What is NginxNginx is a proxy server that provides lightweight web services or reverse proxy services and some Mail services like SMTP(Simple Mail Transfer Protocol). Installation12345jack123@Jack:~$ docker run -d -p 4030:80 --name nginx01 nginxjack123@Jack:~$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc34fb6833670 nginx &quot;/docker-entrypoint.…&quot; 4 hours ago Up 4 hours 0.0.0.0:4030-&gt;80/tcp, :::4030-&gt;80/tcp nginx01 RunPrepare target-servers123# Run two tomcats as target serversdocker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat02 tomcat Check IP1234567891011121314151617181920docker inspect tomcat01...&quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;0f87964862cd2ef5d4638747e268c375fdabc919bc4907fa8a3ebdf7c88a82b2&quot;, &quot;EndpointID&quot;: &quot;b21c95e8d90240017e94bdd4cdcc800011ce4888f1ab82e58e905083318b932a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.3&quot;, # IP here! &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;DriverOpts&quot;: null &#125; &#125;... Proxy Configuration In docker, Nginx’s configuration file lies in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf 1234567891011121314151617181920212223242526272829303132333435363738# find config filejack123@Jack:~$ docker exec -it nginx01 /bin/bashroot@c34fb6833670:/# cd /etc/nginx/conf.d/root@c34fb6833670:/etc/nginx/conf.d# lsdefault.conf# config proxyvim default.conf# &lt;Reverse_Proxy_NAME&gt;: avoid &#x27;_&#x27;, use &#x27;-&#x27; instead# &lt;IP_in_Docker_Network&gt; use &#x27;docker inspect&#x27; to find &lt;IP_in_Docker_Network&gt;# &lt;Port&gt;: use internal port, for tomcat, it&#x27;s 8080. As for mysql, it&#x27;s 3306.# &lt;Weight_Number&gt;: how many times in a row that this server will be queried.# upstream &lt;Reverse_Proxy_NAME&gt; &#123;# server &lt;IP_in_Docker_Network&gt;:&lt;Port&gt; weight=&lt;Weight_Number&gt;;# ...;# &#125;upstream tomcat-test &#123; server 172.17.0.3:8080 weight=1; server 172.17.0.4:8080 weight=1;&#125;server &#123; listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; proxy_pass http://tomcat-test; # corresponding to &lt;Reverse_Proxy_NAME&gt; &#125;......&#125; TODO: http:80 rewrite to https:403 … Reload1docker exec ngnix01 nginx -s reload Test12345678CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc34fb6833670 nginx &quot;/docker-entrypoint.…&quot; 5 hours ago Up 5 hours 0.0.0.0:4030-&gt;80/tcp, :::4030-&gt;80/tcp nginx01fef556ef916b tomcat &quot;catalina.sh run&quot; 5 hours ago Up 5 hours 0.0.0.0:49155-&gt;8080/tcp, :::49155-&gt;8080/tcp tomcat0273424c88f93d tomcat &quot;catalina.sh run&quot; 5 hours ago Up 5 hours 0.0.0.0:49154-&gt;8080/tcp, :::49154-&gt;8080/tcp tomcat01# Testcurl localhost:4030 # Success TODO–&gt; read source code rewrite ngnix with C &#x2F; Java if possible","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"middleware","slug":"middleware","permalink":"https://gold-jack.github.io/tags/middleware/"}]},{"title":"Swagger2","slug":"notes/Swagger2","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:47:08.999Z","comments":true,"path":"2022/09/28/notes/Swagger2/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Swagger2/","excerpt":"","text":"Swagger2Introduction 可以通过Swagger给比较难理解的类、方法、属性，增加注释信息 接口文档实时更新 可以进行在线测试 配置文件Swagger2Config.java1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket docket(Environment environment) &#123; // 设置要显示的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 通过environment.acceptsProfiles(profiles)判断是否处在设定的环境中 boolean isEnv = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(isEnv) // 判断是否启动Swagger，若为false，则Swagger不能在浏览器中访问 .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.example.swagger2.controller&quot;))// .paths(PathSelectors.ant(&quot;/example/**&quot;)) .build(); &#125; private ApiInfo apiInfo() &#123; Contact emailContact = new Contact(&quot;Gold_Jack&quot;, &quot;www.goldjack.com&quot;, &quot;gold_jack@163.com&quot;); return new ApiInfo(&quot;Gold_Jack的Swagger2测试&quot;, &quot;2022/6/26测试——1&quot;, &quot;v_1.6.3&quot;, &quot;https://jack.gold.cn/&quot;, emailContact, &quot;Apache 2.8&quot;, &quot;apache.li/policy2&quot;, new ArrayList&lt;&gt;()); &#125;&#125; pom.xml1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- swagger2 组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.properties123# server.port = 8081# spring.profiles.active=dev 表明是开发环境，配合Docket.enable(environment.profiles())使用 Docket.enable()效果 docket成功开启 失败，docket未开启 1😱 Could not render e, see the console. @注解 常用注解 @ApiModel 用于类 @ApiModelPorperty 用于属性 @ApiOperation 用于方法 @ApiParam 用于传入的参数 User123456789101112131415@Data@NoArgsConstructor@AllArgsConstructor@ApiModel(&quot;用户信息&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) private String username; @ApiModelProperty(&quot;密码&quot;) private String password; @ApiModelProperty(&quot;权限等级&quot;) private Integer authLevel;&#125; Controller123456789101112131415161718192021222324252627282930313233@ApiModel(&quot;网址映射&quot;)@RestControllerpublic class Controller &#123; private final Integer DEFAULT_AUTH_LEVEL = 0; private final Integer ADMIN_AUTH_LEVEL = 9; @ApiOperation(&quot;连接测试&quot;) @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; // 所有 return 实体类; 的方法，实体类会自动被加载进Swagger @ApiOperation(&quot;getUser方法测试&quot;) @GetMapping(&quot;/get-user&quot;) public User getUser() &#123; User testUser = new User(&quot;jack_test&quot;, &quot;admin_test&quot;, ADMIN_AUTH_LEVEL); return testUser; &#125; @ApiOperation(&quot;postUser方法测试&quot;) @PostMapping(&quot;/post-user&quot;) public User postUser(@RequestBody @ApiParam(&quot;用户登录信息&quot;) User userLogin) &#123; // @RequestBody申明可以消除报错 return userLogin; &#125; @ApiOperation(&quot;登陆测试&quot;) @GetMapping(&quot;/login&quot;) public String login(@ApiParam(&quot;用户名&quot;) String username,@ApiParam(&quot;密码&quot;) String password) &#123; return &quot;登陆成功&quot; + &quot;\\n&quot; + (new User(username, password, DEFAULT_AUTH_LEVEL)); &#125;&#125; 测试Swagger接口网址：localhost:&#x2F;swagger-ui.html Models Controllers 特别报错说明 Failed to start bean ‘documentationPluginsBootstrapper’ 1234567org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is java.lang.NullPointerException: Cannot invoke &quot;org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.toString()&quot; because the return value of &quot;springfox.documentation.spi.service.contexts.Orderings.patternsCondition(springfox.docume ntation.RequestHandler)&quot; is null 在application.properties中添加如下配置 1spring.mvc.pathmatch.matching-strategy=ant-path-matcher","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]},{"title":"Nodejs","slug":"notes/Nodejs","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:46:17.003Z","comments":true,"path":"2022/09/28/notes/Nodejs/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Nodejs/","excerpt":"","text":"Nodejs 淘宝镜像设置 1npm install -g cnpm --registry=https://registry.npm.taobao.org node-sass版本问题，重新安装 12npm uninstall node-sassnpm i -D sass npm : 无法加载文件 E:\\nodejs\\node_global\\cnpm.ps1,因为在此系统上禁止运行脚本。有关详细信息,请参阅 https:&#x2F;go.microsoft. com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。 1234567PS C:\\Windows\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): Y # 输入 YPS C:\\Windows\\system32&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]},{"title":"Spring-security","slug":"notes/Spring-Security","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:46:43.202Z","comments":true,"path":"2022/09/28/notes/Spring-Security/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Spring-Security/","excerpt":"","text":"Spring-SecuritySpring-Security新版解决方案 Spring Security without the WebSecurityConfigurerAdapter ​ https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter 关于Swagger2 + Spring-Security可能产生的冲突说明 swagger2在启动springboot项目时报错，参考swagger2笔记中在application.properties中添加代码的方法 由于spring-security的验证，导致swagger2的ui界面，即/swagger-ui.html无法访问。在spring-security配置类中，设置antMatchers(&quot;swagger*&quot;).permitAll()可以解决 权限图 ConfigurationSwagger2Config.java 详细配置参考Swagger2.md笔记 123456789101112131415161718192021@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket docket(Environment environment) &#123; // 设置要显示的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 通过environment.acceptsProfiles(profiles)判断是否处在设定的环境中 boolean isEnv = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2)// .apiInfo(apiInfo()) .enable(isEnv) // 判断是否启动Swagger，若为false，则Swagger不能在浏览器中访问 .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.example.springsecurityrelearn.controller&quot;))// .paths(PathSelectors.ant(&quot;/example/**&quot;)) .build(); &#125;&#125; ApplicationSecurityConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configuration@EnableWebSecuritypublic class ApplicationSecurityConfig &#123; @Autowired private PasswordEncoder passwordEncoder; // 密码加密类 @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123; http.authorizeHttpRequests((authz) -&gt; authz .antMatchers(&quot;/&quot;, &quot;/css/*&quot;, &quot;/js/*&quot;).permitAll() .antMatchers(&quot;/swagger*&quot;).permitAll() // 可以进入swagger-ui.html .antMatchers(&quot;/api/*&quot;).hasRole(STUDENT.name()) // 仅STUDENT可以访问/api下的目录 .anyRequest().authenticated()) .httpBasic(Customizer.withDefaults()); return http.build(); &#125; // 这里的WebSecurityCustomizer的ignoring功能，可以用上面的HttpSecurity.antMatchers().permitAll()替代 // Suggest using .antMatchers().permitAll() instead// @Bean// public WebSecurityCustomizer webSecurityCustomizer() &#123;// return (web) -&gt; web// .ignoring().antMatchers(&quot;/v2/api-docs&quot;, &quot;/configuration/**&quot;, &quot;/swagger*/**&quot;, &quot;/webjars/**&quot;);// &#125; @Bean public UserDetailsService userDetailsService() &#123; UserDetails annaSmithUser = User.builder() .username(&quot;annasmith&quot;) .password(passwordEncoder.encode(&quot;password&quot;)) .roles(STUDENT.name()) .build(); UserDetails lindaUser = User.builder() .username(&quot;linda&quot;) .password(passwordEncoder.encode(&quot;password&quot;)) .roles(ADMIN.name()) .build(); return new InMemoryUserDetailsManager( // List&lt;UserDetails&gt;类型，一起注入 annaSmithUser, lindaUser ); &#125;&#125; PasswordConfig.java123456789@Configurationpublic class PasswordConfig &#123; @Bean public PasswordEncoder passwordEncoder() &#123; // BCryptPasswordEncoder是最经典的加密类 return new BCryptPasswordEncoder(BCryptPasswordEncoder.BCryptVersion.$2B, 10); &#125;&#125; ApplicationUserRole.java1234567891011121314151617// 通过import ApplicationUserPermission.* 可以直接使用ApplicationUserPermission枚举类中的参数import static com.example.springsecurityrelearn.config.ApplicationUserPermission.*;public enum ApplicationUserRole &#123; STUDENT(Sets.newHashSet()), // Sets.newHashSet()方法需要依赖google的guava包 ADMIN(Sets.newHashSet(COURSE_READ, COURSE_WRITE, STUDENT_READ, STUDENT_WRITE)); private final Set&lt;ApplicationUserPermission&gt; permissions; ApplicationUserRole(Set&lt;ApplicationUserPermission&gt; permissions) &#123; this.permissions = permissions; &#125; public Set&lt;ApplicationUserPermission&gt; getPermissions() &#123; return permissions; &#125;&#125; dependency—google.guava 123456&lt;!-- guava组件简化Set操作--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt;&lt;/dependency&gt; ApplicationUserPermission.java1234567891011121314151617public enum ApplicationUserPermission &#123; STUDENT_READ(&quot;student:read&quot;), STUDENT_WRITE(&quot;student:write&quot;), COURSE_READ(&quot;course:read&quot;), COURSE_WRITE(&quot;course:write&quot;); private final String permission; ApplicationUserPermission(String permission) &#123; this.permission = permission; &#125; public String getPermission() &#123; return permission; &#125;&#125; pojo.Student12345678@Data@NoArgsConstructor@AllArgsConstructorpublic class Student &#123; private Integer studentId; private String studentName;&#125; Controller123456789101112131415161718@RestController@RequestMapping(&quot;/api/students&quot;)public class StudentController &#123; private static final List&lt;Student&gt; STUDENTS = List.of( new Student(1, &quot;Alan Jones&quot;), new Student(2, &quot;Jack Wilder&quot;), new Student(3, &quot;Maria Lanny&quot;) ); @GetMapping(path = &quot;&#123;studentId&#125;&quot;) // 通过localhost:8080/api/students/&#123;studentId&#125;访问具体的学生信息 public Student getStudentInfo(@PathVariable(&quot;studentId&quot;) Integer studentId) &#123; return STUDENTS.stream() .filter(student -&gt; studentId.equals(student.getStudentId())) .findFirst() .orElseThrow(IllegalStateException::new); &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]},{"title":"Vue3","slug":"notes/Vue","date":"2022-09-27T16:00:00.000Z","updated":"2022-09-28T09:47:33.549Z","comments":true,"path":"2022/09/28/notes/Vue/","link":"","permalink":"https://gold-jack.github.io/2022/09/28/notes/Vue/","excerpt":"","text":"Vue3创建Vue项目12345678910111213141516171819202122232425262728293031323334# 初始化项目E:\\IDEA-Workspace\\vue-projects&gt;vue init webpack vue-element-ui? Project name vue-element-ui? Project description A Vue.js project? Author jack &lt;gold_jack@163.com&gt;? Vue build standalone? Install vue-router? No # 以下选NO是为了手动体验安装过程? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) no vue-cli · Generated &quot;vue-element-ui&quot;.# Project initialization finished!# ========================# 进入项目目录cd &lt;PROJECT_NAME&gt;# 安装vue-routercnpm install vue-router@3.1.3 --save-dev# 安装element-ui库cnpm i element-ui -S# 安装node_modulescnpm install# 安装sass-loader和node-sasscnpm install sass-loader node-sass --save-devcnpm install sass-loader@7.3.1 node-sass@4.14.1 --save-dev # 如果nodejs是Node14版本 Node-sass 版本对应表 NodeJS Supported node-sass version Node Module Node 17 7.0+ 102 Node 16 6.0+ 93 Node 15 5.0+, &lt;7.0 88 Node 14 4.14+ 83 Node 13 4.13+, &lt;5.0 79 Node 12 4.12+ 72 Node 11 4.10+, &lt;5.0 67 Node 10 4.9+, &lt;6.0 64 Node 8 4.5.3+, &lt;5.0 57 Node &lt;8 &lt;5.0 &lt;57 node-sass版本 sass-loader版本 4.3.0 4.1.1 4.7.2 7.0.3 4.7.2 7.3.1 4.14.1 7.3.1 6.0.1 10.0.1","categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"}],"tags":[{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"}]}],"categories":[{"name":"notes","slug":"notes","permalink":"https://gold-jack.github.io/categories/notes/"},{"name":"leetcode","slug":"leetcode","permalink":"https://gold-jack.github.io/categories/leetcode/"}],"tags":[{"name":"ai_painting","slug":"ai-painting","permalink":"https://gold-jack.github.io/tags/ai-painting/"},{"name":"diffusion model","slug":"diffusion-model","permalink":"https://gold-jack.github.io/tags/diffusion-model/"},{"name":"textual inversion","slug":"textual-inversion","permalink":"https://gold-jack.github.io/tags/textual-inversion/"},{"name":"dp","slug":"dp","permalink":"https://gold-jack.github.io/tags/dp/"},{"name":"graph","slug":"graph","permalink":"https://gold-jack.github.io/tags/graph/"},{"name":"tree","slug":"tree","permalink":"https://gold-jack.github.io/tags/tree/"},{"name":"recursion","slug":"recursion","permalink":"https://gold-jack.github.io/tags/recursion/"},{"name":"dfs","slug":"dfs","permalink":"https://gold-jack.github.io/tags/dfs/"},{"name":"re","slug":"re","permalink":"https://gold-jack.github.io/tags/re/"},{"name":"prefix_sum","slug":"prefix-sum","permalink":"https://gold-jack.github.io/tags/prefix-sum/"},{"name":"double_pointer","slug":"double-pointer","permalink":"https://gold-jack.github.io/tags/double-pointer/"},{"name":"greed","slug":"greed","permalink":"https://gold-jack.github.io/tags/greed/"},{"name":"sort","slug":"sort","permalink":"https://gold-jack.github.io/tags/sort/"},{"name":"string","slug":"string","permalink":"https://gold-jack.github.io/tags/string/"},{"name":"BST","slug":"BST","permalink":"https://gold-jack.github.io/tags/BST/"},{"name":"AVL","slug":"AVL","permalink":"https://gold-jack.github.io/tags/AVL/"},{"name":"hash_table","slug":"hash-table","permalink":"https://gold-jack.github.io/tags/hash-table/"},{"name":"big_int","slug":"big-int","permalink":"https://gold-jack.github.io/tags/big-int/"},{"name":"find_patterns","slug":"find-patterns","permalink":"https://gold-jack.github.io/tags/find-patterns/"},{"name":"traverse","slug":"traverse","permalink":"https://gold-jack.github.io/tags/traverse/"},{"name":"substring","slug":"substring","permalink":"https://gold-jack.github.io/tags/substring/"},{"name":"DFS","slug":"DFS","permalink":"https://gold-jack.github.io/tags/DFS/"},{"name":"springboot-vue","slug":"springboot-vue","permalink":"https://gold-jack.github.io/tags/springboot-vue/"},{"name":"middleware","slug":"middleware","permalink":"https://gold-jack.github.io/tags/middleware/"},{"name":"linux","slug":"linux","permalink":"https://gold-jack.github.io/tags/linux/"}]}